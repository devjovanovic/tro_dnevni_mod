<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet href="file:///C|/Users/Uros/Desktop/Casa Campo/pawno/xml/pawndoc.xsl" type="text/xsl"?>
<doc source="C:\Users\Uros\Desktop\Casa Campo\gamemodes\Moduli\cos.pwn">
	<assembly>
		<name>cos.pwn</name>
	</assembly>

	<!-- general -->
	<general>
		<!--  <transition target[^/]+/>  :::::::: README ::::::::  To read the generated XML output, copy `pawndoc.xsl` to `pawno/xml/`.  This information goes very close to the top of the generated XML documentation  (because of include dependency orders), but doesn't appear in the visual output.  There is a bug in the compiler related to outputting documentation on state  transitions (<a href="https://github.com/Zeex/pawn/issues/184" />).  So after  generation of the XML file, you should clean it up with the following RegEx  replacement:  Search: <transition target[^/]+/>  Replace: (nothing)  This works 99% of the time, though you may get one where the corrupted target  includes the character `/`, in which case you should manually delete them.  Note  that YSI now includes manual documentation for transitions, but these all  include the parameter `keep="true"`, which exists simply to not match that  RegEx.  I also put the search at the top of this block so it is easier to find  in the output code.  --> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_cell">  <section>  Description  </section>  Provides a few functions for manipulating the bits in single cells.  Note  that this is distinct from the y_bit library.  <section>  Version  </section>  0.2  </library> <p/> <library name="y_scriptinit">  <section>  Description  </section>  This file provides "OnScriptInit" and "OnScriptExit" which are called at the  start and end of the current script, regardless of what the type of the  script is (note: doesn't support NPC modes).  It also provides  "YSI_FILTERSCRIPT" as a (partial) replacement for "FILTERSCRIPT" which  detects what the mode is at runtime for a more reliable system (but it is a  run-time variable, not a compile-time constant).  <section>  Version  </section>  1.0  </library> <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <library name="y_debug">  <section>  Description  </section>  <p>Ensures debug levels are set and defines debug functions.</p>  <p>General debug levels:</p>  <ul>  <li>-1 - Run-time selected debug level.</li>  <li>0 - No debug information.</li>  <li>1 - Callbacks and timers.</li>  <li>2 - Remote functions.</li>  <li>3 - Stock functions.</li>  <li>4 - Static functions.</li>  <li>5 - Code.</li>  <li>6 - Loops.</li>  <li>7 - Extra loop code.</li>  </ul>  <p>If you use <c>P:0</c> you get an optional debug print controlled by the  global state <c>ysi_debug</c> - which is either on or off.</p>  <section>  Version  </section>  1.0  <section>  Functions  </section>  <subsection>  Inline  </subsection><ul>  <symbol name="Debug_Code">Runs defined code if a certain level is active.</symbol>  <symbol name="Debug_Print">Prints the formatted string provided at the given level.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Debug_PrintArray">Print several items from an array for debugging purposes.</symbol>  <symbol name="Debug_Enable">Turn on level 0 prints.</symbol>  <symbol name="Debug_Disable">Turn off level 0 prints.</symbol>  <symbol name="Debug_Level">Set the debug level when the code is compiled with  <c>_DEBUG=-1</c>, which means full run-time selection.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="P:&lt;0-6&gt;">Print a message.</symbol>  <symbol name="P:C">Run debug code.</symbol>  <symbol name="P:E">Print an error message.</symbol>  <symbol name="P:W">Print a warning message.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="_DEBUG">Debugging level to use.</symbol>  </ul>  </library> <p/> <library name="y_amx">  <section>  Description  </section>  Allows a script access to information about itself, such as function names.  This can be used for a range of things, including automatic callback hooking  and testing.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_va">  <section>  Description  </section>  This library currently provides two functions - va_printf and va_format  which perform printf and format using variable arguments passed to another  function.  This is bsed on the variable parameter passing method based on code by Zeex.  See page 15 of the code optimisations topic.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_bit">  <section>  Description  </section>  Provides functions for bit manipulation and bit arrays greater than 32bits.  The arrays are usually bigger than required due to cell boundaries but this  shouldn't cause a major problem (bit tests on the 101st bit of a 100 bit  array won't return 0 for out of bounds, but the 129th will).  Note that y_commands has a few optimisations which bypass the code in here  so any modifications to bit array layouts will need to be reflected there.  <section>  Version  </section>  0.2  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="Bit_Set">Sets a slot to the given value.</symbol>  <symbol name="Bit_Get">Gets a slot state.</symbol>  <symbol name="Bit_SetAll">Sets all the slots in an array to the same thing.</symbol>  <symbol name="Bit_GetCount">Gets the number of 1s in a bit array.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="Bit_Bits">Gets the number of cells required for a bit array.</symbol>  <symbol name="Bit_Let">Sets a slot to 1.</symbol>  <symbol name="Bit_Vet">Sets a slot to 0.</symbol>  <symbol name="Bit_GetBits">Gets the bit at a slot unsafely.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="CELLSHIFT">Number of bits that can hold "cellbits"</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Bit">Bit array type.</symbol>  </ul>  </library> <p/> <library name="y_als">  <section>  Description  </section>  Provides a number of macros for making ALS (Advanced Library System)  callback hooking simpler.  <section>  Version  </section>  1.0  </library> 
	</general>

	<members>

		<!-- enumerations -->
		<member name="T:AMX_FUNCSTUBNT" value="2">
			<tagname value="AMX_FUNCSTUBNT"/>
			<member name="C:AMX_FUNCSTUBNT_ADDRESS" value="0">
			</member>
			<member name="C:AMX_FUNCSTUBNT_NAMEOFS" value="1">
			</member>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
		</member>
		<member name="T:AMX_HDR" value="17">
			<tagname value="AMX_HDR"/>
			<member name="C:AMX_HDR_SIZE" value="0">
			</member>
			<member name="C:AMX_HDR_MAGIC" value="1">
			</member>
			<member name="C:AMX_HDR_FILE_VERSION" value="2">
			</member>
			<member name="C:AMX_HDR_AMX_VERSION" value="3">
			</member>
			<member name="C:AMX_HDR_FLAGS" value="4">
			</member>
			<member name="C:AMX_HDR_DEFSIZE" value="5">
			</member>
			<member name="C:AMX_HDR_COD" value="6">
			</member>
			<member name="C:AMX_HDR_DAT" value="7">
			</member>
			<member name="C:AMX_HDR_HEA" value="8">
			</member>
			<member name="C:AMX_HDR_STP" value="9">
			</member>
			<member name="C:AMX_HDR_CIP" value="10">
			</member>
			<member name="C:AMX_HDR_PUBLICS" value="11">
			</member>
			<member name="C:AMX_HDR_NATIVES" value="12">
			</member>
			<member name="C:AMX_HDR_LIBRARIES" value="13">
			</member>
			<member name="C:AMX_HDR_PUBVARS" value="14">
			</member>
			<member name="C:AMX_HDR_TAGS" value="15">
			</member>
			<member name="C:AMX_HDR_NAMETABLE" value="16">
			</member>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="ProfilerInit"/>
		</member>
		<member name="T:AsmContext" value="21">
			<tagname value="AsmContext"/>
			<member name="C:AsmContext_buffer" value="0">
			</member>
			<member name="C:AsmContext_buffer_size" value="1">
			</member>
			<member name="C:AsmContext_buffer_offset" value="2">
			</member>
			<member name="C:AsmContext_error" value="3">
			</member>
			<member name="C:AsmContext_error_handler" value="4">
			</member>
			<member name="C:AsmContext_label_names" value="5">
				<size value="8"/>
			</member>
			<member name="C:AsmContext_labels" value="13">
				<size value="8"/>
			</member>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="T:CodeScanMatcher" value="171">
			<tagname value="CodeScanMatcher"/>
			<member name="C:CodeScanMatcher_func" value="0">
			</member>
			<member name="C:CodeScanMatcher_user_data" value="1">
			</member>
			<member name="C:CodeScanMatcher_code" value="2">
				<size value="128"/>
			</member>
			<member name="C:CodeScanMatcher_len" value="130">
			</member>
			<member name="C:CodeScanMatcher_offset" value="131">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_start" value="133">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holeidx" value="135">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holes" value="137">
				<size value="32"/>
			</member>
			<member name="C:CodeScanMatcher_next" value="169">
			</member>
			<member name="C:CodeScanMatcher_flags" value="170">
			</member>
			<referrer name="CodeScanDeref"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:CodeScanner" value="163">
			<tagname value="CodeScanner"/>
			<member name="C:CodeScanMatch_func" value="0">
			</member>
			<member name="C:CodeScanMatch_size" value="1">
			</member>
			<member name="C:CodeScanMatch_type" value="2">
			</member>
			<member name="C:CodeScanMatch_heap" value="3">
			</member>
			<member name="C:CodeScanMatch_stack" value="4">
			</member>
			<member name="C:CodeScanMatch_params" value="5">
			</member>
			<member name="C:CodeScanMatch_cip" value="6">
			</member>
			<member name="C:CodeScanMatch_holes" value="7">
				<size value="16"/>
			</member>
			<member name="C:CodeScanMatch_name" value="23">
				<size value="8"/>
			</member>
			<member name="C:CodeScanner_first" value="31">
			</member>
			<member name="C:CodeScanner_minn" value="32">
			</member>
			<member name="C:CodeScanner_jump_switch" value="33">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_target" value="65">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_stack" value="97">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_heap" value="129">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_state" value="161">
			</member>
			<member name="C:CodeScanner_param" value="162">
			</member>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:DisasmContext" value="22">
			<tagname value="DisasmContext"/>
			<member name="C:DisasmContext_start_ip" value="0">
			</member>
			<member name="C:DisasmContext_end_ip" value="1">
			</member>
			<member name="C:DisasmContext_nip" value="2">
			</member>
			<member name="C:DisasmContext_cip" value="3">
			</member>
			<member name="C:DisasmContext_opcode" value="4">
				<tagname value="Opcode"/>
			</member>
			<member name="C:DisasmContext_insn" value="5">
				<size value="17"/>
			</member>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Hooks_GetStubEntry"/>
		</member>
		<member name="T:E_HOOK_NAME_REPLACEMENT_DATA" value="34">
			<tagname value="E_HOOK_NAME_REPLACEMENT_DATA"/>
			<member name="C:E_HOOK_NAME_REPLACEMENT_SHORT" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_LONG" value="16">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MIN" value="32">
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MAX" value="33">
			</member>
		</member>
		<member name="T:E_PRE_HOOK" value="17">
			<tagname value="E_PRE_HOOK"/>
			<member name="C:E_PRE_HOOK_NAME" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_PRE_HOOK_VALUE" value="16">
			</member>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_DoAllHooks"/>
		</member>
		<member name="T:OpcodeInsnInfo" value="17">
			<tagname value="OpcodeInsnInfo"/>
			<member name="C:OpcodeInsnInfo_name" value="0">
				<size value="15"/>
			</member>
			<member name="C:OpcodeInsnInfo_num_opers" value="15">
			</member>
			<member name="C:OpcodeInsnInfo_needs_reloc" value="16">
				<tagname value="bool"/>
			</member>
		</member>
		<member name="T:ProfCallInfo" value="2">
			<tagname value="ProfCallInfo"/>
			<member name="C:pci_index" value="0">
			</member>
			<member name="C:pci_start_time" value="1">
			</member>
			<referrer name="enter_public"/>
		</member>
		<member name="T:ProfEntryCode" value="8">
			<tagname value="ProfEntryCode"/>
			<member name="C:pec_push_c0" value="0">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_address" value="1">
			</member>
			<member name="C:pec_push_c1" value="2">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_index" value="3">
			</member>
			<member name="C:pec_push_c2" value="4">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_8" value="5">
			</member>
			<member name="C:pec_call" value="6">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_call_enter" value="7">
			</member>
			<referrer name="new_pec"/>
		</member>
		<member name="T:ProfPublicInfo" value="3">
			<tagname value="ProfPublicInfo"/>
			<member name="C:ppi_child_time" value="0">
			</member>
			<member name="C:ppi_total_time" value="1">
			</member>
			<member name="C:ppi_num_calls" value="2">
			</member>
		</member>
		<member name="T:vInfo" value="51">
			<tagname value="vInfo"/>
			<member name="C:ID" value="0">
			</member>
			<member name="C:Model" value="1">
			</member>
			<member name="C:vImeVlasnika" value="2">
				<size value="26"/>
			</member>
			<member name="C:Cena" value="28">
			</member>
			<member name="C:Zakljucan" value="29">
			</member>
			<member name="C:Mod" value="30">
				<size value="14"/>
			</member>
			<member name="C:Boja1" value="44">
			</member>
			<member name="C:Boja2" value="45">
			</member>
			<member name="C:PosX" value="46">
				<tagname value="Float"/>
			</member>
			<member name="C:PosY" value="47">
				<tagname value="Float"/>
			</member>
			<member name="C:PosZ" value="48">
				<tagname value="Float"/>
			</member>
			<member name="C:PosA" value="49">
				<tagname value="Float"/>
			</member>
			<member name="C:voziloLabel" value="50">
				<tagname value="Text3D"/>
			</member>
		</member>

		<!-- constants -->
		<member name="C:AMX_HDR_OFFSET_AMX_VERSION" value="7">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_CIP" value="28">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_COD" value="12">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DAT" value="16">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DEFSIZE" value="10">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FILE_VERSION" value="6">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FLAGS" value="8">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_HEA" value="20">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_LIBRARIES" value="40">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_MAGIC" value="4">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NAMETABLE" value="52">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NATIVES" value="36">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBLICS" value="32">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBVARS" value="44">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_SIZE" value="0">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_STP" value="24">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_TAGS" value="48">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:NUM_OPCODES" value="138">
			<referrer name="IsOpcodeValid"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="UnrelocateOpcode"/>
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmNext"/>
		</member>
		<member name="C:__Pawn" value="778">
		</member>
		<member name="C:cellbits" value="32">
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Bit_Set"/>
			<referrer name="Iter_Func@Bits"/>
			<referrer name="Iter_Func@Blanks"/>
		</member>
		<member name="C:cellmax" value="2147483647">
			<referrer name="operator!(Float:)"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="exit_public"/>
			<referrer name="Range"/>
			<referrer name="YVA2_FoundCall"/>
		</member>
		<member name="C:cellmin" value="-2147483648">
			<referrer name="operator-(Float:)"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<referrer name="exit_public"/>
			<referrer name="Random"/>
			<referrer name="endofline"/>
			<referrer name="ishex"/>
			<referrer name="isnumeric"/>
			<referrer name="SkipWhitespace"/>
			<referrer name="Trim"/>
			<referrer name="Range"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="C:debug" value="2">
			<referrer name="RelocateOpcodeNow"/>
		</member>
		<member name="C:false" value="0">
			<tagname value="bool"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="v"/>
		</member>
		<member name="C:true" value="1">
			<tagname value="bool"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetTagNameFromID"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRun"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="boolstr"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="v"/>
		</member>

		<!-- variables -->
		<member name="F:AMX_BASE_ADDRESS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_AMX_VERSION">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_CIP">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_COD">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetGlobal"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_HEADER_DAT">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_DEFSIZE">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_FILE_VERSION">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_FLAGS">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_HEA">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_LIBRARIES">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_MAGIC">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_NAMETABLE">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_NATIVES">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromNativeIndex"/>
			<referrer name="AMX_GetNativeIndexFromEntry"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_PUBLICS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromPublicIndex"/>
			<referrer name="AMX_GetPublicIndexFromEntry"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_PUBVARS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_SIZE">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_STP">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_TAGS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_REAL_ADDRESS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_REAL_DATA">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetGlobalAddress"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
		</member>
		<member name="F:ASM_ARGUMENTS_OFFSET">
			<referrer name="AsmGetArgOffset"/>
		</member>
		<member name="F:ASM_CALLER_FRAME_OFFSET">
		</member>
		<member name="F:ASM_CTRL_CIP">
		</member>
		<member name="F:ASM_CTRL_COD">
		</member>
		<member name="F:ASM_CTRL_DAT">
		</member>
		<member name="F:ASM_CTRL_FRM">
		</member>
		<member name="F:ASM_CTRL_HEA">
		</member>
		<member name="F:ASM_CTRL_JIT">
		</member>
		<member name="F:ASM_CTRL_JMP">
		</member>
		<member name="F:ASM_CTRL_STK">
		</member>
		<member name="F:ASM_CTRL_STP">
		</member>
		<member name="F:ASM_LOCALS_OFFSET">
		</member>
		<member name="F:ASM_RETURN_ADDR_OFFSET">
		</member>
		<member name="F:FALSE">
			<tagname value="bool"/>
		</member>
		<member name="F:I@">
		</member>
		<member name="F:J@">
		</member>
		<member name="F:NULL">
		</member>
		<member name="F:O@V_">
			<referrer name="O@A_"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:Q@">
			<referrer name="S@"/>
			<referrer name="G@"/>
			<referrer name="F@"/>
		</member>
		<member name="F:REF">
		</member>
		<member name="F:TRUE">
			<tagname value="bool"/>
			<referrer name="YVA2_DummyPush"/>
		</member>
		<member name="F:UNIQUE_SYMBOL_DOESNT_EXIST">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:VI">
			<referrer name="SacuvajVozilo"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnVehicleMod@001"/>
			<referrer name="@yH_OnVehicleSpawn@001"/>
			<referrer name="@yH_OnPlayerStateChange@001"/>
			<referrer name="v"/>
			<referrer name="nvozilo"/>
		</member>
		<member name="F:VehicleNames">
			<referrer name="GetVehicleName"/>
		</member>
		<member name="F:VoziloID">
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnPlayerStateChange@001"/>
		</member>
		<member name="F:YSI_FILTERSCRIPT">
			<tagname value="bool"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<referrer name="YVers_OnScriptInit"/>
		</member>
		<member name="F:YSI_gDebugLevel">
			<referrer name="Debug_Level"/>
		</member>
		<member name="F:YSI_gPlayerIP">
			<referrer name="OnPlayerConnect"/>
			<referrer name="OnPlayerDisconnect"/>
		</member>
		<member name="F:YSI_g_sCodeEnd">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCodeSpace">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<referrer name="CGen_AddCodeSpace"/>
		</member>
		<member name="F:YSI_g_sContexts">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sInitialised">
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sLength">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sMaxNesting">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sPassthroughNestings">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sReplacePtr">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacements">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsLongOrder">
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsShortOrder">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sSkips">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sStacks">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:_@">
			<attribute name="public"/>
			<referrer name="Y@"/>
		</member>
		<member name="F:__date">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__time">
		</member>
		<member name="F:gBase">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="DisasmInit"/>
			<referrer name="DisasmReloc"/>
			<referrer name="DisasmWriteCode"/>
		</member>
		<member name="F:gCodeScanCallback_match">
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:gDat">
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanGetMatchFunc"/>
			<referrer name="CodeScanGetMatchAddress"/>
		</member>
		<member name="F:gHdr">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gHdr">
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gInitialized">
			<tagname value="bool"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gPreviousWriteOffset">
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<referrer name="AsmGetPreviousWriteOffset"/>
		</member>
		<member name="F:g_args">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_call_depth">
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
		</member>
		<member name="F:g_call_stack">
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
		</member>
		<member name="F:g_nargs">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_num_pecs">
			<referrer name="new_pec"/>
		</member>
		<member name="F:g_num_publics">
			<referrer name="exit_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="ProfilerWriteData"/>
		</member>
		<member name="F:g_pecs">
			<referrer name="new_pec"/>
			<referrer name="ProfilerInit"/>
		</member>
		<member name="F:g_publics">
			<referrer name="exit_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="ProfilerWriteData"/>
		</member>
		<member name="F:insn_table">
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
		</member>
		<member name="F:opcode_table">
			<tagname value="Opcode"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:opcode_table_is_ready">
			<tagname value="bool"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>

		<!-- functions -->
		<member name="M:operator!(Float:)" syntax="operator!(Float:)(oper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="cellmax"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(_:,Float:)" syntax="operator%(_:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(Float:,_:)" syntax="operator%(Float:,_:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator%(Float:,Float:)" syntax="operator%(Float:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Float:,_:)" syntax="operator!=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator!=(Float:,Float:)" syntax="operator!=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(_:,Float:)" syntax="operator-(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,_:)" syntax="operator-(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator+(Float:,_:)" syntax="operator+(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<referrer name="nvozilo"/>
			<dependency name="float"/>
			<dependency name="floatadd"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator/(_:,Float:)" syntax="operator/(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,_:)" syntax="operator/(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator*(Float:,_:)" syntax="operator*(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatmul"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator++(Float:)" syntax="operator++(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator+(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:)" syntax="operator-(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<referrer name="RandomFloat"/>
			<dependency name="cellmin"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator--(Float:)" syntax="operator--(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator-(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,Float:)" syntax="operator-(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator--(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(Float:,Float:)" syntax="operator+(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator++(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,Float:)" syntax="operator/(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(Float:,Float:)" syntax="operator*(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,Float:)" syntax="operator==(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,_:)" syntax="operator==(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(Float:,Float:)" syntax="operator&gt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;(Float:,_:)" syntax="operator&gt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(_:,Float:)" syntax="operator&gt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,Float:)" syntax="operator&gt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,_:)" syntax="operator&gt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;=(_:,Float:)" syntax="operator&gt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,Float:)" syntax="operator&lt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,_:)" syntax="operator&lt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;(_:,Float:)" syntax="operator&lt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,Float:)" syntax="operator&lt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,_:)" syntax="operator&lt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;=(_:,Float:)" syntax="operator&lt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:@CO_HookChain" syntax="@CO_HookChain()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="@CO_ScriptInit"/>
		</member>
		<member name="M:@CO_ScriptInit" syntax="@CO_ScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<referrer name="@CO_HookChain"/>
		</member>
		<member name="M:@RETOnPlayerCommandText" syntax="@RETOnPlayerCommandText()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@RETOnRconCommand" syntax="@RETOnRconCommand()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@_yHCheckpoint" syntax="@_yHCheckpoint()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHCommand" syntax="@_yHCommand()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHContainer" syntax="@_yHContainer()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamic" syntax="@_yHDynamic()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamicCP" syntax="@_yHDynamicCP()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHInventory" syntax="@_yHInventory()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHObject" syntax="@_yHObject()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHTextDraw" syntax="@_yHTextDraw()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHUpdate" syntax="@_yHUpdate()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@receivepacket" syntax="@receivepacket(packet[], size, source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="packet">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@receivestring" syntax="@receivestring(message[], source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yH_OnDialogResponse@001" syntax="@yH_OnDialogResponse@001(playerid, dialogid, response, listitem, inputtext[])">
			<attribute name="public"/>
			<stacksize value="18"/>
			<dependency name="Cena"/>
			<dependency name="DestroyDynamic3DTextLabel"/>
			<dependency name="GRESKA"/>
			<dependency name="GetName"/>
			<dependency name="GetPlayerFacingAngle"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="GetVehicleParamsEx"/>
			<dependency name="ID"/>
			<dependency name="NovacMinus"/>
			<dependency name="PosA"/>
			<dependency name="PosX"/>
			<dependency name="PosY"/>
			<dependency name="PosZ"/>
			<dependency name="SCM"/>
			<dependency name="SPD"/>
			<dependency name="SetVehicleParamsForPlayer"/>
			<dependency name="SetVehicleToRespawn"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="VoziloID"/>
			<dependency name="Zakljucan"/>
			<dependency name="foreach"/>
			<dependency name="format"/>
			<dependency name="strcmp"/>
			<dependency name="vImeVlasnika"/>
			<dependency name="voziloLabel"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yH_OnGameScriptExit@001" syntax="@yH_OnGameScriptExit@001()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="SacuvajVozilo"/>
		</member>
		<member name="M:@yH_OnGameScriptInit@001" syntax="@yH_OnGameScriptInit@001()">
			<attribute name="public"/>
			<stacksize value="207"/>
			<dependency name="Boja1"/>
			<dependency name="Boja2"/>
			<dependency name="Cena"/>
			<dependency name="CreateDynamic3DTextLabel"/>
			<dependency name="CreateVehicle"/>
			<dependency name="GetVehicleName"/>
			<dependency name="GetVehicleName"/>
			<dependency name="ID"/>
			<dependency name="INI_ParseFile"/>
			<dependency name="Model"/>
			<dependency name="PosA"/>
			<dependency name="PosX"/>
			<dependency name="PosY"/>
			<dependency name="PosZ"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="fexist"/>
			<dependency name="format"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<dependency name="vImeVlasnika"/>
			<dependency name="voziloLabel"/>
		</member>
		<member name="M:@yH_OnPlayerStateChange@001" syntax="@yH_OnPlayerStateChange@001(playerid, newstate, oldstate)">
			<attribute name="public"/>
			<stacksize value="157"/>
			<dependency name="Cena"/>
			<dependency name="GetVehicleName"/>
			<dependency name="GetVehicleName"/>
			<dependency name="Model"/>
			<dependency name="SPD"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="VoziloID"/>
			<dependency name="format"/>
			<dependency name="strcmp"/>
			<dependency name="vImeVlasnika"/>
			<param name="playerid">
			</param>
			<param name="newstate">
			</param>
			<param name="oldstate">
			</param>
		</member>
		<member name="M:@yH_OnVehicleMod@001" syntax="@yH_OnVehicleMod@001(playerid, vehicleid, componentid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="GetName"/>
			<dependency name="GetVehicleComponentType"/>
			<dependency name="ID"/>
			<dependency name="IsPlayerInVehicle"/>
			<dependency name="Mod"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="strcmp"/>
			<dependency name="vImeVlasnika"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="componentid">
			</param>
		</member>
		<member name="M:@yH_OnVehicleSpawn@001" syntax="@yH_OnVehicleSpawn@001(vehicleid)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="AddVehicleComponent"/>
			<dependency name="GetName"/>
			<dependency name="ID"/>
			<dependency name="Mod"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="foreach"/>
			<dependency name="strcmp"/>
			<dependency name="vImeVlasnika"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:AMX_DoNothing" syntax="AMX_DoNothing()">
			<stacksize value="1"/>
			<referrer name="AMX_GetGlobal"/>
		</member>
		<member name="M:AMX_GetBaseCount" syntax="AMX_GetBaseCount(table, &amp;base, &amp;count)">
			<stacksize value="1"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_TABLE_LIBRARIES"/>
			<dependency name="AMX_TABLE_NATIVES"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_TABLE_PUBVARS"/>
			<dependency name="AMX_TABLE_TAGS"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="base">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntry" syntax="AMX_GetEntry(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="42"/>
			<referrer name="AMX_GetPointer"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntryFromNativeIndex" syntax="AMX_GetEntryFromNativeIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryFromPublicIndex" syntax="AMX_GetEntryFromPublicIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryPointer" syntax="AMX_GetEntryPointer(entry)">
			<stacksize value="1"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetEntryPrefix" syntax="AMX_GetEntryPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="9"/>
			<referrer name="AMX_GetPointerPrefix"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_CountInvalidPublics"/>
			<referrer name="AMX_OnScriptInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetEntrySuffix" syntax="AMX_GetEntrySuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="10"/>
			<referrer name="AMX_GetPointerSuffix"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetGlobal" syntax="AMX_GetGlobal()">
			<stacksize value="4"/>
			<referrer name="Debug_OnScriptInit"/>
			<dependency name="AMX_DoNothing"/>
			<dependency name="AMX_HEADER_COD"/>
		</member>
		<member name="M:AMX_GetGlobalAddress" syntax="AMX_GetGlobalAddress(...)">
			<stacksize value="2"/>
			<dependency name="AMX_REAL_DATA"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetName" syntax="AMX_GetName(table, idx, buffer[], pattern[], exact)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetNamePrefix" syntax="AMX_GetNamePrefix(table, idx, buffer[], pattern)">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNameSuffix" syntax="AMX_GetNameSuffix(table, idx, buffer[], pattern)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNativeIndexFromEntry" syntax="AMX_GetNativeIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetPointer" syntax="AMX_GetPointer(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<referrer name="AMX_GetValue"/>
			<dependency name="AMX_GetEntry"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetPointerPrefix" syntax="AMX_GetPointerPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValuePrefix"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPointerSuffix" syntax="AMX_GetPointerSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValueSuffix"/>
			<dependency name="AMX_GetEntrySuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPublicIndexFromEntry" syntax="AMX_GetPublicIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetRelativeAddress" syntax="AMX_GetRelativeAddress(...)">
			<stacksize value="2"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetStringFromEntry" syntax="AMX_GetStringFromEntry(entry, str[], size)">
			<stacksize value="6"/>
			<referrer name="Hooks_GetAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_ReadString"/>
			<param name="entry">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_GetValue" syntax="AMX_GetValue(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<dependency name="AMX_GetPointer"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetValuePrefix" syntax="AMX_GetValuePrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetValueSuffix" syntax="AMX_GetValueSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerSuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_OnScriptInit" syntax="AMX_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="9"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="HookChain_OnScriptInit"/>
			<dependency name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_SortReplacements"/>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:AMX_RawRead" syntax="AMX_RawRead(addr)">
			<stacksize value="1"/>
			<referrer name="AMX_Read"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_RawWrite" syntax="AMX_RawWrite(addr, value)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_Read" syntax="AMX_Read(addr)">
			<stacksize value="50"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_CompareNextCell"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="AMX_OnScriptInit"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_RawRead"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitNop"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="OP_PUSH_C"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_ReadArray" syntax="AMX_ReadArray(addr, dest[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadString" syntax="AMX_ReadString(addr, str[], len)">
			<stacksize value="3"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadUnpackedString" syntax="AMX_ReadUnpackedString(addr, str[], len)">
			<stacksize value="2"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_TraceCode" syntax="AMX_TraceCode(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_TraceMemory" syntax="AMX_TraceMemory(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_HEA"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_Write" syntax="AMX_Write(addr, value)">
			<stacksize value="1"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_WriteArray" syntax="AMX_WriteArray(addr, src[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_WriteString" syntax="AMX_WriteString(addr, str[], len)">
			<stacksize value="4"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AbsToRel" syntax="AbsToRel(address)">
			<stacksize value="3"/>
			<referrer name="ReadPhysMemory"/>
			<referrer name="WritePhysMemory"/>
			<referrer name="ReadPhysMemoryCell"/>
			<referrer name="WritePhysMemoryCell"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:AddVehicleComponent" syntax="AddVehicleComponent(vehicleid, componentid)">
			<attribute name="native"/>
			<referrer name="@yH_OnVehicleSpawn@001"/>
			<param name="vehicleid">
			</param>
			<param name="componentid">
			</param>
		</member>
		<member name="M:AsmClearError" syntax="AsmClearError(ctx[])">
			<stacksize value="5"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmSetError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAdd" syntax="AsmEmitAdd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAddC" syntax="AsmEmitAddC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitAddrAlt" syntax="AsmEmitAddrAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAddrPri" syntax="AsmEmitAddrPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAlignAlt" syntax="AsmEmitAlignAlt(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAlignPri" syntax="AsmEmitAlignPri(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAnd" syntax="AsmEmitAnd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_AND"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitBounds" syntax="AsmEmitBounds(ctx[], bound)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BOUNDS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="bound">
			</param>
		</member>
		<member name="M:AsmEmitBreak" syntax="AsmEmitBreak(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BREAK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCall" syntax="AsmEmitCall(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallAbs" syntax="AsmEmitCallAbs(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="24"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallLabelStringize" syntax="AsmEmitCallLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCell" syntax="AsmEmitCell(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitOperand"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitCmps" syntax="AsmEmitCmps(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CMPS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitConstAlt" syntax="AsmEmitConstAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitConstPri" syntax="AsmEmitConstPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitDec" syntax="AsmEmitDec(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitDecAlt" syntax="AsmEmitDecAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecI" syntax="AsmEmitDecI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecPri" syntax="AsmEmitDecPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecS" syntax="AsmEmitDecS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitEq" syntax="AsmEmitEq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitEqCAlt" syntax="AsmEmitEqCAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitEqCPri" syntax="AsmEmitEqCPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitFill" syntax="AsmEmitFill(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_FILL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitGeq" syntax="AsmEmitGeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitGrtr" syntax="AsmEmitGrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitHalt" syntax="AsmEmitHalt(ctx[], code)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="code">
			</param>
		</member>
		<member name="M:AsmEmitHeap" syntax="AsmEmitHeap(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HEAP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitIdxaddr" syntax="AsmEmitIdxaddr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIdxaddrB" syntax="AsmEmitIdxaddrB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitInc" syntax="AsmEmitInc(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitIncAlt" syntax="AsmEmitIncAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncI" syntax="AsmEmitIncI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncPri" syntax="AsmEmitIncPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncS" syntax="AsmEmitIncS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitInstruction" syntax="AsmEmitInstruction(ctx[], opcode, ...)">
			<tagname value="AsmError"/>
			<stacksize value="8"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<referrer name="AsmEmitAdd"/>
			<referrer name="AsmEmitAddC"/>
			<referrer name="AsmEmitAddrAlt"/>
			<referrer name="AsmEmitAddrPri"/>
			<referrer name="AsmEmitAlignAlt"/>
			<referrer name="AsmEmitAlignPri"/>
			<referrer name="AsmEmitAnd"/>
			<referrer name="AsmEmitBounds"/>
			<referrer name="AsmEmitBreak"/>
			<referrer name="AsmEmitCall"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AsmEmitCmps"/>
			<referrer name="AsmEmitConstAlt"/>
			<referrer name="AsmEmitConstPri"/>
			<referrer name="AsmEmitDec"/>
			<referrer name="AsmEmitDecAlt"/>
			<referrer name="AsmEmitDecI"/>
			<referrer name="AsmEmitDecPri"/>
			<referrer name="AsmEmitDecS"/>
			<referrer name="AsmEmitEq"/>
			<referrer name="AsmEmitEqCAlt"/>
			<referrer name="AsmEmitEqCPri"/>
			<referrer name="AsmEmitFill"/>
			<referrer name="AsmEmitGeq"/>
			<referrer name="AsmEmitGrtr"/>
			<referrer name="AsmEmitHalt"/>
			<referrer name="AsmEmitHeap"/>
			<referrer name="AsmEmitIdxaddr"/>
			<referrer name="AsmEmitIdxaddrB"/>
			<referrer name="AsmEmitInc"/>
			<referrer name="AsmEmitIncAlt"/>
			<referrer name="AsmEmitIncI"/>
			<referrer name="AsmEmitIncPri"/>
			<referrer name="AsmEmitIncS"/>
			<referrer name="AsmEmitInvert"/>
			<referrer name="AsmEmitJeq"/>
			<referrer name="AsmEmitJgeq"/>
			<referrer name="AsmEmitJgrtr"/>
			<referrer name="AsmEmitJleq"/>
			<referrer name="AsmEmitJless"/>
			<referrer name="AsmEmitJneq"/>
			<referrer name="AsmEmitJnz"/>
			<referrer name="AsmEmitJsgeq"/>
			<referrer name="AsmEmitJsgrtr"/>
			<referrer name="AsmEmitJsleq"/>
			<referrer name="AsmEmitJsless"/>
			<referrer name="AsmEmitJump"/>
			<referrer name="AsmEmitJzer"/>
			<referrer name="AsmEmitLctrl"/>
			<referrer name="AsmEmitLeq"/>
			<referrer name="AsmEmitLess"/>
			<referrer name="AsmEmitLidx"/>
			<referrer name="AsmEmitLidxB"/>
			<referrer name="AsmEmitLoadAlt"/>
			<referrer name="AsmEmitLoadPri"/>
			<referrer name="AsmEmitLoad"/>
			<referrer name="AsmEmitLoadI"/>
			<referrer name="AsmEmitLoadSAlt"/>
			<referrer name="AsmEmitLoadSPri"/>
			<referrer name="AsmEmitLodbI"/>
			<referrer name="AsmEmitLrefAlt"/>
			<referrer name="AsmEmitLrefPri"/>
			<referrer name="AsmEmitLrefSAlt"/>
			<referrer name="AsmEmitLrefSPri"/>
			<referrer name="AsmEmitMoveAlt"/>
			<referrer name="AsmEmitMovePri"/>
			<referrer name="AsmEmitMovs"/>
			<referrer name="AsmEmitNeg"/>
			<referrer name="AsmEmitNeq"/>
			<referrer name="AsmEmitNop"/>
			<referrer name="AsmEmitNot"/>
			<referrer name="AsmEmitOr"/>
			<referrer name="AsmEmitPopAlt"/>
			<referrer name="AsmEmitPopPri"/>
			<referrer name="AsmEmitProc"/>
			<referrer name="AsmEmitPushAdr"/>
			<referrer name="AsmEmitPushAlt"/>
			<referrer name="AsmEmitPushC"/>
			<referrer name="AsmEmitPushPri"/>
			<referrer name="AsmEmitPush"/>
			<referrer name="AsmEmitPushS"/>
			<referrer name="AsmEmitRet"/>
			<referrer name="AsmEmitRetn"/>
			<referrer name="AsmEmitSctrl"/>
			<referrer name="AsmEmitSdiv"/>
			<referrer name="AsmEmitSdivAlt"/>
			<referrer name="AsmEmitSgeq"/>
			<referrer name="AsmEmitSgrtr"/>
			<referrer name="AsmEmitShl"/>
			<referrer name="AsmEmitShlCAlt"/>
			<referrer name="AsmEmitShlCPri"/>
			<referrer name="AsmEmitShrCAlt"/>
			<referrer name="AsmEmitShrCPri"/>
			<referrer name="AsmEmitShr"/>
			<referrer name="AsmEmitSignAlt"/>
			<referrer name="AsmEmitSignPri"/>
			<referrer name="AsmEmitSleq"/>
			<referrer name="AsmEmitSless"/>
			<referrer name="AsmEmitSmul"/>
			<referrer name="AsmEmitSmulC"/>
			<referrer name="AsmEmitSshr"/>
			<referrer name="AsmEmitSrefAlt"/>
			<referrer name="AsmEmitSrefPri"/>
			<referrer name="AsmEmitSrefSAlt"/>
			<referrer name="AsmEmitSrefSPri"/>
			<referrer name="AsmEmitStack"/>
			<referrer name="AsmEmitStorAlt"/>
			<referrer name="AsmEmitStorPri"/>
			<referrer name="AsmEmitStorI"/>
			<referrer name="AsmEmitStorSAlt"/>
			<referrer name="AsmEmitStorSPri"/>
			<referrer name="AsmEmitStrbI"/>
			<referrer name="AsmEmitSub"/>
			<referrer name="AsmEmitSubAlt"/>
			<referrer name="AsmEmitSwapAlt"/>
			<referrer name="AsmEmitSwapPri"/>
			<referrer name="AsmEmitSysreqC"/>
			<referrer name="AsmEmitSysreqD"/>
			<referrer name="AsmEmitSysreqPri"/>
			<referrer name="AsmEmitUdiv"/>
			<referrer name="AsmEmitUdivAlt"/>
			<referrer name="AsmEmitUmul"/>
			<referrer name="AsmEmitXchg"/>
			<referrer name="AsmEmitXor"/>
			<referrer name="AsmEmitZero"/>
			<referrer name="AsmEmitZeroAlt"/>
			<referrer name="AsmEmitZeroPri"/>
			<referrer name="AsmEmitZeroS"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="AsmEmitOperand"/>
			<dependency name="gPreviousWriteOffset"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:AsmEmitInvert" syntax="AsmEmitInvert(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INVERT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeq" syntax="AsmEmitJeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJeqLabelStringize" syntax="AsmEmitJeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeqRel" syntax="AsmEmitJeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgeq" syntax="AsmEmitJgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgeqLabelStringize" syntax="AsmEmitJgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgeqRel" syntax="AsmEmitJgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgrtr" syntax="AsmEmitJgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgrtrLabelStringize" syntax="AsmEmitJgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgrtrRel" syntax="AsmEmitJgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJleq" syntax="AsmEmitJleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJleqLabelStringize" syntax="AsmEmitJleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJleqRel" syntax="AsmEmitJleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJless" syntax="AsmEmitJless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJlessLabelStringize" syntax="AsmEmitJlessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJlessRel" syntax="AsmEmitJlessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJneq" syntax="AsmEmitJneq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJneqLabelStringize" syntax="AsmEmitJneqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJneqRel" syntax="AsmEmitJneqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJnz" syntax="AsmEmitJnz(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJnzLabelStringize" syntax="AsmEmitJnzLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJnzRel" syntax="AsmEmitJnzRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrel" syntax="AsmEmitJrel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JREL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrelLabelStringize" syntax="AsmEmitJrelLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JREL"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeq" syntax="AsmEmitJsgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgeqLabelStringize" syntax="AsmEmitJsgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeqRel" syntax="AsmEmitJsgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtr" syntax="AsmEmitJsgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrLabelStringize" syntax="AsmEmitJsgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrRel" syntax="AsmEmitJsgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsleq" syntax="AsmEmitJsleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsleqLabelStringize" syntax="AsmEmitJsleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsleqRel" syntax="AsmEmitJsleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsless" syntax="AsmEmitJsless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJslessLabelStringize" syntax="AsmEmitJslessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJslessRel" syntax="AsmEmitJslessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJump" syntax="AsmEmitJump(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJumpInstruction" syntax="AsmEmitJumpInstruction(ctx[], opcode, offset)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitJeqRel"/>
			<referrer name="AsmEmitJgeqRel"/>
			<referrer name="AsmEmitJgrtrRel"/>
			<referrer name="AsmEmitJleqRel"/>
			<referrer name="AsmEmitJlessRel"/>
			<referrer name="AsmEmitJneqRel"/>
			<referrer name="AsmEmitJnzRel"/>
			<referrer name="AsmEmitJsgeqRel"/>
			<referrer name="AsmEmitJsgrtrRel"/>
			<referrer name="AsmEmitJsleqRel"/>
			<referrer name="AsmEmitJslessRel"/>
			<referrer name="AsmEmitJumpRel"/>
			<referrer name="AsmEmitJzerRel"/>
			<referrer name="AsmEmitJrel"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelInstruction" syntax="AsmEmitJumpLabelInstruction(ctx[], opcode, label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitCallLabelStringize"/>
			<referrer name="AsmEmitJeqLabelStringize"/>
			<referrer name="AsmEmitJgeqLabelStringize"/>
			<referrer name="AsmEmitJgrtrLabelStringize"/>
			<referrer name="AsmEmitJleqLabelStringize"/>
			<referrer name="AsmEmitJlessLabelStringize"/>
			<referrer name="AsmEmitJneqLabelStringize"/>
			<referrer name="AsmEmitJnzLabelStringize"/>
			<referrer name="AsmEmitJsgeqLabelStringize"/>
			<referrer name="AsmEmitJsgrtrLabelStringize"/>
			<referrer name="AsmEmitJsleqLabelStringize"/>
			<referrer name="AsmEmitJslessLabelStringize"/>
			<referrer name="AsmEmitJumpLabelStringize"/>
			<referrer name="AsmEmitJzerLabelStringize"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitJumpStringize"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="gPreviousWriteOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelStringize" syntax="AsmEmitJumpLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpRel" syntax="AsmEmitJumpRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpStringize" syntax="AsmEmitJumpStringize(ctx[], label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="10"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzer" syntax="AsmEmitJzer(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJzerLabelStringize" syntax="AsmEmitJzerLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzerRel" syntax="AsmEmitJzerRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLabelStringize" syntax="AsmEmitLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="11"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLctrl" syntax="AsmEmitLctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitLeq" syntax="AsmEmitLeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLess" syntax="AsmEmitLess(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidx" syntax="AsmEmitLidx(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidxB" syntax="AsmEmitLidxB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitLoad" syntax="AsmEmitLoad(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadAlt" syntax="AsmEmitLoadAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadI" syntax="AsmEmitLoadI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLoadPri" syntax="AsmEmitLoadPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadSAlt" syntax="AsmEmitLoadSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLoadSPri" syntax="AsmEmitLoadSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLodbI" syntax="AsmEmitLodbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LODB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitLrefAlt" syntax="AsmEmitLrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefPri" syntax="AsmEmitLrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefSAlt" syntax="AsmEmitLrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLrefSPri" syntax="AsmEmitLrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitMoveAlt" syntax="AsmEmitMoveAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovePri" syntax="AsmEmitMovePri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovs" syntax="AsmEmitMovs(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitNeg" syntax="AsmEmitNeg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNeq" syntax="AsmEmitNeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNop" syntax="AsmEmitNop(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AMX_Read"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNot" syntax="AsmEmitNot(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOpcode" syntax="AsmEmitOpcode(ctx[], opcode)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="RelocateOpcode"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOperand" syntax="AsmEmitOperand(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<dependency name="AsmEmitCell"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitOr" syntax="AsmEmitOr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_OR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPadding" syntax="AsmEmitPadding(ctx[], op)">
			<stacksize value="7"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="IsOpcodeValid"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopAlt" syntax="AsmEmitPopAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopArgs" syntax="AsmEmitPopArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitStack"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPopPri" syntax="AsmEmitPopPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitProc" syntax="AsmEmitProc(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PROC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPush" syntax="AsmEmitPush(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitPushAdr" syntax="AsmEmitPushAdr(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ADR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitPushAlt" syntax="AsmEmitPushAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushArg" syntax="AsmEmitPushArg(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmGetArgOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushC" syntax="AsmEmitPushC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushNumArgs"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitPushNumArgs" syntax="AsmEmitPushNumArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushPri" syntax="AsmEmitPushPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushS" syntax="AsmEmitPushS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushArg"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenPushVariable"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitRet" syntax="AsmEmitRet(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RET"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitRetn" syntax="AsmEmitRetn(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RETN"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSctrl" syntax="AsmEmitSctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSdiv" syntax="AsmEmitSdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSdivAlt" syntax="AsmEmitSdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgeq" syntax="AsmEmitSgeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgrtr" syntax="AsmEmitSgrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShl" syntax="AsmEmitShl(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShlCAlt" syntax="AsmEmitShlCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShlCPri" syntax="AsmEmitShlCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShr" syntax="AsmEmitShr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShrCAlt" syntax="AsmEmitShrCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShrCPri" syntax="AsmEmitShrCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitSignAlt" syntax="AsmEmitSignAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSignPri" syntax="AsmEmitSignPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSleq" syntax="AsmEmitSleq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSless" syntax="AsmEmitSless(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmul" syntax="AsmEmitSmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmulC" syntax="AsmEmitSmulC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitSrefAlt" syntax="AsmEmitSrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefPri" syntax="AsmEmitSrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefSAlt" syntax="AsmEmitSrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSrefSPri" syntax="AsmEmitSrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSshr" syntax="AsmEmitSshr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SSHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStack" syntax="AsmEmitStack(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPopArgs"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STACK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitStorAlt" syntax="AsmEmitStorAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorI" syntax="AsmEmitStorI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStorPri" syntax="AsmEmitStorPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorSAlt" syntax="AsmEmitStorSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStorSPri" syntax="AsmEmitStorSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStrbI" syntax="AsmEmitStrbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STRB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitSub" syntax="AsmEmitSub(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSubAlt" syntax="AsmEmitSubAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapAlt" syntax="AsmEmitSwapAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapPri" syntax="AsmEmitSwapPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreq" syntax="AsmEmitSysreq(ctx[], name[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreqC" syntax="AsmEmitSysreqC(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSysreqD" syntax="AsmEmitSysreqD(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_D"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSysreqPri" syntax="AsmEmitSysreqPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdiv" syntax="AsmEmitUdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdivAlt" syntax="AsmEmitUdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUmul" syntax="AsmEmitUmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXchg" syntax="AsmEmitXchg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XCHG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXor" syntax="AsmEmitXor(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XOR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZero" syntax="AsmEmitZero(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitZeroAlt" syntax="AsmEmitZeroAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroPri" syntax="AsmEmitZeroPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroS" syntax="AsmEmitZeroS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmFindLabelIndex" syntax="AsmFindLabelIndex(ctx[], hash)">
			<stacksize value="2"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<dependency name="AsmContext_label_names"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="hash">
			</param>
		</member>
		<member name="M:AsmGetArgOffset" syntax="AsmGetArgOffset(n)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPushArg"/>
			<dependency name="ASM_ARGUMENTS_OFFSET"/>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmGetBufferSize" syntax="AsmGetBufferSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCode" syntax="AsmGetCode(ctx[])">
			<stacksize value="21"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCodeSize" syntax="AsmGetCodeSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetError" syntax="AsmGetError(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetErrorHandler" syntax="AsmGetErrorHandler(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetJumpAddressFromOffset" syntax="AsmGetJumpAddressFromOffset(ctx[], offset)">
			<stacksize value="22"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmGetPreviousWriteOffset" syntax="AsmGetPreviousWriteOffset()">
			<stacksize value="1"/>
			<dependency name="gPreviousWriteOffset"/>
		</member>
		<member name="M:AsmHashLabel" syntax="AsmHashLabel(label[])">
			<stacksize value="4"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmInit" syntax="AsmInit(ctx[], buffer[], size)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmInitPtr" syntax="AsmInitPtr(ctx[], buffer, size)">
			<tagname value="AsmError"/>
			<stacksize value="2"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CGen_UseCodeSpace"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmRaiseError" syntax="AsmRaiseError(ctx[], error)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmSetError"/>
			<dependency name="CallFunction"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetError" syntax="AsmSetError(ctx[], error)">
			<stacksize value="1"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmClearError"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetErrorHandler" syntax="AsmSetErrorHandler(ctx[], error_handler)">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
			</param>
		</member>
		<member name="M:AsmSetErrorHandlerName" syntax="AsmSetErrorHandlerName(ctx[], error_handler[])">
			<tagname value="AsmError"/>
			<stacksize value="4"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="GetPublicAddressFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Bit_Bits" syntax="Bit_Bits(size)">
			<stacksize value="1"/>
			<param name="size">
				Number of bits required.
			</param>
			  <returns>  Number of cells required for the bit array.  </returns> 
		</member>
		<member name="M:Bit_Display" syntax="Bit_Display(array[], size)">
			<stacksize value="141"/>
			<dependency name="Bit_Display"/>
			<dependency name="Cell_ReverseBits"/>
			<dependency name="format"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Bit_FastSet" syntax="Bit_FastSet(array[], slot, set, size)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				State to set the slot to.
			</param>
			<param name="size">
				Size of array.
			</param>
			        <remarks>  Exactly the same as "Bit_Set", but as a macro not a function.  native Bit_FastSet(BitArray:array&lt;&gt;, slot, bool:set, size = sizeof (array));  </remarks> 
		</member>
		<member name="M:Bit_Get" syntax="Bit_Get(array[], slot)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <param name="size">Size of array.</param>  <returns>  State of the provided slot, 0 on fail.  </returns>  <remarks>  -  native Bit_Get(BitArray:array&lt;&gt;, slot);  </remarks> 
		</member>
		<member name="M:Bit_GetBit" syntax="Bit_GetBit(array[], slot)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <returns>  State of the provided slot, 0 on fail.  </returns>  <remarks>  Unsafe but faster for when you're sure you're within range.  </remarks> 
		</member>
		<member name="M:Bit_GetCount" syntax="Bit_GetCount(array[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_CountBits"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array to count.
			</param>
			<param name="size">
				Size of array.
			</param>
			    <returns>  Number of 1s in the array.  </returns>  <remarks>  Code from:  <a href="http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />  native Bit_Count(BitArray:array&lt;&gt;, size = sizeof (array));  </remarks> 
		</member>
		<member name="M:Bit_Let" syntax="Bit_Let(array[], slot)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <remarks>  Sets the slot to 1.  </remarks> 
		</member>
		<member name="M:Bit_Mask" syntax="Bit_Mask(value)">
			<stacksize value="1"/>
			<param name="value">
				Value to get the mask for
			</param>
			  <returns>  The bit in the array slot to use.  </returns> 
		</member>
		<member name="M:Bit_Set" syntax="Bit_Set(array[], slot, set)">
			<stacksize value="1"/>
			<dependency name="cellbits"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				State to set the slot to.
			</param>
			      <param name="size">Size of array.</param> 
		</member>
		<member name="M:Bit_SetAll" syntax="Bit_SetAll(array[], set, size)">
			<stacksize value="6"/>
			<dependency name="memset"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array to set all values of.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				Wether to set them all 0 or 1.
			</param>
			<param name="size">
				Size of array.
			</param>
			     
		</member>
		<member name="M:Bit_Slot" syntax="Bit_Slot(value)">
			<stacksize value="1"/>
			<param name="value">
				Value to get the slot for.
			</param>
			  <returns>  The true array slot for this value.  </returns> 
		</member>
		<member name="M:Bit_Vet" syntax="Bit_Vet(array[], slot)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <remarks>  Sets the slot to 0.  </remarks> 
		</member>
		<member name="M:CGen_AddCodeSpace" syntax="CGen_AddCodeSpace(num)">
			<stacksize value="4"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="num">
			</param>
		</member>
		<member name="M:CGen_GetAddr" syntax="CGen_GetAddr(func[])">
			<stacksize value="6"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="funcidx"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_GetCodeSpace" syntax="CGen_GetCodeSpace()">
			<stacksize value="3"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_SetupCodeSpace" syntax="CGen_SetupCodeSpace()">
			<stacksize value="5"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_GetAddr"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_UseCodeSpace" syntax="CGen_UseCodeSpace(ctx[])">
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:Call" syntax="Call(address, auto_pop)">
			<stacksize value="5"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallFunction" syntax="CallFunction(address, ...)">
			<stacksize value="5"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="AMX_OnScriptInit"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallLocalFunction" syntax="CallLocalFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallN" syntax="CallN(address, args_to_push, auto_pop)">
			<stacksize value="6"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallNative" syntax="CallNative(index, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="index">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallNativeByAddress" syntax="CallNativeByAddress(address, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallRemoteFunction" syntax="CallRemoteFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:Cell_CompressRight" syntax="Cell_CompressRight(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_CompressRightPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<summary>  Cell_CompressRight(GLOBAL_TAG_TYPES:x, m);  </summary>      <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_CompressRightPrecomputed" syntax="Cell_CompressRightPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_CompressRight"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the compression.
			</param>
			<summary>  Cell_CompressRightPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5]);  </summary>        <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Very briefly, do "x &amp; m", to select certain bits, then shift those bits  by various amounts so that they are consecutive:  x = 0b110011  m = 0b011010  x &amp; m = 0b010010  From here, because the mask was three bits we know we want just those three  bits in the LSBs, so the answer becomes:  0b000101  Just read this question, it has a diagram:  <a href="http://stackoverflow.com/questions/28282869/shift-masked-bits-to-the-lsb" />  </remarks> 
		</member>
		<member name="M:Cell_CountBits" syntax="Cell_CountBits(data)">
			<stacksize value="1"/>
			<referrer name="Bit_GetCount"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBits(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The number of 1s (set bits) in the input.  </returns>  <remarks>  1)  Example: 0  Returns: 0  2)  Example: 1  Returns: 1  3)  Example: 0x01010101  Returns: 4  I rewrote this in assembly just to see if I could pretty much.  I also  rewrote the lookup version in assembly.  In theory it should be faster, but  the marshalling of data was a little awkward.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeft" syntax="Cell_ExpandLeft(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_ExpandLeftPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<summary>  Cell_ExpandLeft(GLOBAL_TAG_TYPES:x, m)  </summary>      <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeftPrecomputed" syntax="Cell_ExpandLeftPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_ExpandLeft"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the expansion.
			</param>
			<summary>  Cell_ExpandLeftPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5])  </summary>        <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  The reverse of "Cell_CompressRightPrecomputed".  Doesn't return exactly the  original number before a compression, just the original number ANDed with  the mask "m".  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBit" syntax="Cell_GetLowestBit(data)">
			<stacksize value="1"/>
			<referrer name="Iter_Func@Bits"/>
			<referrer name="Iter_Func@Blanks"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBit(number);  </summary>  <param name="number">The number to get the lowest set bit of.</param>  <returns>  The integer position of the lowest set bit.  </returns>  <remarks>  1)  Example: 0b00000000000000000000000000000001  Returns: 0  2)  Example: 0b00000000000000000000000000001000  Returns: 3  3)  Example: 0b00010001100011000011100010001000  Returns: 3  NOTE: This function returns "0" for both numbers with the "1" bit set AND  the number "0", which has NO bits set.  Check that the number is valid  before passing it to this function.  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBitEx" syntax="Cell_GetLowestBitEx(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBitEx(number);  </summary>  <param name="number">The number to get the lowest set bit of PLUS ONE.</param>  <returns>  The integer position of the lowest set bit PLUS ONE.  </returns>  <remarks>  This function is identical to "Cell_GetLowestBit", but gives different  results for 0 and non-zero numbers.  The examples below all have a result  one higher than the "Cell_GetLowestBit" function.  1)  Example: 0b00000000000000000000000000000001  Returns: 1  2)  Example: 0b00000000000000000000000000001000  Returns: 4  3)  Example: 0b00010001100011000011100010001000  Returns: 4  4)  Example: 0  Returns: 0  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestComponent" syntax="Cell_GetLowestComponent(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestComponent(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The lowest set bit.  </returns>  <remarks>  Similar to Cell_GetLowestBit, but returns the bit, not the position of the  bit.  1)  Example: 0b00000000000000000000000000000001  Returns: 0b00000000000000000000000000000001  2)  Example: 0b00000000000000000000000000001000  Returns: 0b00000000000000000000000000001000  3)  Example: 0b00010001100011000011100010001000  Returns: 0b00000000000000000000000000001000  </remarks> 
		</member>
		<member name="M:Cell_PrecomputeMaskPermutation" syntax="Cell_PrecomputeMaskPermutation(m)">
			<stacksize value="10"/>
			<referrer name="Cell_CompressRight"/>
			<referrer name="Cell_ExpandLeft"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="m">
				The mask.
			</param>
			<summary>  Cell_PrecomputeMaskPermutation(m)  </summary>    <returns>  Five precomputed constants to help expand or contract this mask.  </returns>  <remarks>  The full maths for generalised expansion and contraction is quite complex;  however, much of the inner loop relies only on the mask and not on the value  being manipulated.  Given this we can do a lot of work in advance, say  outside a loop, to avoid repeated calculations.  </remarks> 
		</member>
		<member name="M:Cell_ReverseBits" syntax="Cell_ReverseBits(data)">
			<stacksize value="1"/>
			<referrer name="Bit_Display"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBits(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bits in the input reversed.  </returns>  <remarks>  1)  Example: 0b11110000000000000000000000000000  Becomes: 0b00000000000000000000000000001111  2)  Example: 0b10110011100011110000111110000010  Becomes: 0b01000001111100001111000111001101  3)  Example: 0b01010101010101010101010101010101  Becomes: 0b10101010101010101010101010101010  </remarks> 
		</member>
		<member name="M:Cell_ReverseBytes" syntax="Cell_ReverseBytes(data)">
			<stacksize value="1"/>
			<referrer name="Hooks_CompareNextCell"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBytes(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bytes in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x78563412  2)  Example: 0x01020304  Becomes: 0x04030201  3)  Example: 0xFF00FF00  Becomes: 0x00FF00FF  </remarks> 
		</member>
		<member name="M:Cell_ReverseNibbles" syntax="Cell_ReverseNibbles(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseNibbles(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the nibbles (4-bit chunks) in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x87654321  2)  Example: 0x010F0703  Becomes: 0x3070F010  3)  Example: 0xF0F0F0F0  Becomes: 0x0F0F0F0F  </remarks> 
		</member>
		<member name="M:CodeScanAddJumpTarget" syntax="CodeScanAddJumpTarget(cip, stk, hea, jumpTargets[], num)">
			<stacksize value="4"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="min"/>
			<param name="cip">
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanAddMatcher" syntax="CodeScanAddMatcher(scanner[], searcher[])">
			<stacksize value="4"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="ref"/>
			<param name="scanner">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanAddSwitchTarget" syntax="CodeScanAddSwitchTarget(dctx[], stk, hea, jumpTargets[], num)">
			<stacksize value="6"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="cellbits"/>
			<dependency name="gBase"/>
			<dependency name="gHdr"/>
			<dependency name="min"/>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanCall" syntax="CodeScanCall(cs[], csState[])">
			<stacksize value="3"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheck" syntax="CodeScanCheck(op, dctx[], cs[], fctx[], &amp;next)">
			<tagname value="bool"/>
			<stacksize value="12"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_holes"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_holes"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<dependency name="CodeScanMatcher_start"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_NOP"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="fctx">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheckJumpTarget" syntax="CodeScanCheckJumpTarget(cip, deloc, &amp;stk, &amp;hea, jumpTargets[], num)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="cip">
			</param>
			<param name="deloc">
			</param>
			<param name="stk">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="hea">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanDeref" syntax="CodeScanDeref(v)">
			<stacksize value="1"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatcher"/>
			<param name="v">
			</param>
		</member>
		<member name="M:CodeScanGetFuncName" syntax="CodeScanGetFuncName(addr, name[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanGetMatchType"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="addr">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFunctionAsm" syntax="CodeScanGetFunctionAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionDisasm" syntax="CodeScanGetFunctionDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionScanner" syntax="CodeScanGetFunctionScanner(csm[], ret[], ctx[])">
			<stacksize value="4"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddress" syntax="CodeScanGetMatchAddress(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddressData" syntax="CodeScanGetMatchAddressData(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="CodeScanMatch_cip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAsm" syntax="CodeScanGetMatchAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchDisasm" syntax="CodeScanGetMatchDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchFunc" syntax="CodeScanGetMatchFunc(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchFuncData" syntax="CodeScanGetMatchFuncData(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHeap" syntax="CodeScanGetMatchHeap(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_heap"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHole" syntax="CodeScanGetMatchHole(csm[], idx)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_holes"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:CodeScanGetMatchLength" syntax="CodeScanGetMatchLength(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_size"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchName" syntax="CodeScanGetMatchName(csm[], name[])">
			<stacksize value="5"/>
			<dependency name="CodeScanGetMatchType"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="strcat"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchScanner" syntax="CodeScanGetMatchScanner(csm[], ret[], ctx[], accurate)">
			<stacksize value="7"/>
			<dependency name="CodeScanGetFunctionScanner"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="accurate">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchStack" syntax="CodeScanGetMatchStack(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_stack"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchType" syntax="CodeScanGetMatchType(csm[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetMatchName"/>
			<dependency name="CodeScanGetFuncName"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<param name="csm">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanInit" syntax="CodeScanInit(scanner[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetFunctionScanner"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_params"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="cellmin"/>
			<dependency name="gBase"/>
			<dependency name="gDat"/>
			<dependency name="gHdr"/>
			<param name="scanner">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanMatcherData" syntax="CodeScanMatcherData(searcher[], val)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:CodeScanMatcherInit_" syntax="CodeScanMatcherInit_(searcher[], address, flags)">
			<stacksize value="5"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<dependency name="CodeScanReset"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="address">
			</param>
			<param name="flags">
			</param>
		</member>
		<member name="M:CodeScanMatcherPattern_" syntax="CodeScanMatcherPattern_(searcher[], ...)">
			<stacksize value="10"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Opcode,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanReset" syntax="CodeScanReset(cs[], &amp;next)">
			<stacksize value="1"/>
			<referrer name="CodeScanMatcherInit_"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanResetJumpTargets" syntax="CodeScanResetJumpTargets(jumpTargets[], num)">
			<stacksize value="1"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<param name="jumpTargets">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanRun" syntax="CodeScanRun(csState[])">
			<tagname value="bool"/>
			<stacksize value="205"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStep" syntax="CodeScanStep(dctx[], csState[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStepInternal" syntax="CodeScanStepInternal(dctx[], csState[], &amp;parseState, &amp;parseParam)">
			<tagname value="bool"/>
			<stacksize value="13"/>
			<referrer name="CodeScanStep"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanAddJumpTarget"/>
			<dependency name="CodeScanAddSwitchTarget"/>
			<dependency name="CodeScanCheckJumpTarget"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNext"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CALL_PRI"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JREL"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_R"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="gBase"/>
			<dependency name="true"/>
			<param name="dctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [163] </paraminfo>
			</param>
			<param name="parseState">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parseParam">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CreateDynamic3DTextLabel" syntax="CreateDynamic3DTextLabel()">
			<stacksize value="1"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="nvozilo"/>
		</member>
		<member name="M:CreatePlayerTextDraw" syntax="CreatePlayerTextDraw(playerid, x, y, text[])">
			<tagname value="PlayerText"/>
			<attribute name="native"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CreateVehicle" syntax="CreateVehicle(vehicletype, x, y, z, rotation, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="nvozilo"/>
			<param name="vehicletype">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Debug_Code1" syntax="Debug_Code1(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code2" syntax="Debug_Code2(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code3" syntax="Debug_Code3(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code4" syntax="Debug_Code4(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code5" syntax="Debug_Code5(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code6" syntax="Debug_Code6(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:Debug_Code7" syntax="Debug_Code7(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:Debug_Disable" syntax="Debug_Disable()">
			<stacksize value="1"/>
			<remarks>  Turn off level 0 prints.  </remarks>  <transition target="off"/>

		</member>
		<member name="M:Debug_Enable" syntax="Debug_Enable()">
			<stacksize value="1"/>
			<remarks>  Turn on level 0 prints.  </remarks>  <transition target="on"/>

		</member>
		<member name="M:Debug_Level" syntax="Debug_Level(level)">
			<stacksize value="1"/>
			<dependency name="YSI_gDebugLevel"/>
			<param name="level">
			</param>
			<remarks>  Set the debug level when the code is compiled with <c>_DEBUG=-1</c>, which  means full run-time selection.  </remarks> 
		</member>
		<member name="M:Debug_OnScriptInit" syntax="Debug_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetGlobal"/>
			<dependency name="AMX_HEADER_AMX_VERSION"/>
			<dependency name="AMX_HEADER_CIP"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_DEFSIZE"/>
			<dependency name="AMX_HEADER_FILE_VERSION"/>
			<dependency name="AMX_HEADER_FLAGS"/>
			<dependency name="AMX_HEADER_HEA"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_MAGIC"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_SIZE"/>
			<dependency name="AMX_HEADER_STP"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_REAL_DATA"/>
		</member>
		<member name="M:Debug_Print0" syntax="Debug_Print0(str[], ...)">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="YVers_OnScriptInit"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="CGen_AddCodeSpace"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_Hooks_AddReplacement"/>
			<dependency name="printf"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			<param name="format">str.</param>    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print0("variables: %d, %d", i, j);  </code>  Or:  <code>  P:0("variables: %d, %d", i, j);  </code>  <c>_DEBUG</c> level 0 prints are ALWAYS compiled, but are runtime switched  using the automata <c>ysi_debug</c>.  When then state is <c>ysi_debug :  on</c>, the prints are executed.  When then state is <c>ysi_debug : off</c>,  they aren't.  </remarks> 
		</member>
		<member name="M:Debug_Print1" syntax="Debug_Print1(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print1("variables: %d, %d", i, j);  </code>  Or:  <code>  P:1("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print2" syntax="Debug_Print2(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print2("variables: %d, %d", i, j);  </code>  Or:  <code>  P:2("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print3" syntax="Debug_Print3(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print3("variables: %d, %d", i, j);  </code>  Or:  <code>  P:3("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print4" syntax="Debug_Print4(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print4("variables: %d, %d", i, j);  </code>  Or:  <code>  P:4("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print5" syntax="Debug_Print5(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print5("variables: %d, %d", i, j);  </code>  Or:  <code>  P:5("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print6" syntax="Debug_Print6(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print6("variables: %d, %d", i, j);  </code>  Or:  <code>  P:6("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:Debug_Print7" syntax="Debug_Print7(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print7("variables: %d, %d", i, j);  </code>  Or:  <code>  P:7("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:Debug_PrintArray" syntax="Debug_PrintArray(arr[], size)">
			<stacksize value="108"/>
			<dependency name="Debug_PrintArray"/>
			<dependency name="format"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Debug_SetState" syntax="Debug_SetState()">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="YVers_OnScriptInit"/>
			<transition keep="true" target="ysi_debug : on" source="ysi_debug : "/>  <remarks>  Mostly exists to define the full range of <c>ysi_debug</c> states.  </remarks> <p/> <transition target="on"/>

		</member>
		<member name="M:DestroyDynamic3DTextLabel" syntax="DestroyDynamic3DTextLabel()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
		</member>
		<member name="M:DestroyVehicle" syntax="DestroyVehicle(vehicleid)">
			<attribute name="native"/>
			<referrer name="nvozilo"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:DisasmDecodeInsn" syntax="DisasmDecodeInsn(ctx[])">
			<tagname value="bool"/>
			<stacksize value="24"/>
			<referrer name="DisasmNext"/>
			<referrer name="DisasmNextInsn"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="AMX_Read"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmDump" syntax="DisasmDump(filename[])">
			<stacksize value="4"/>
			<dependency name="DisasmWrite"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetCurIp" syntax="DisasmGetCurIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="DisasmContext_cip"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetInsnName" syntax="DisasmGetInsnName(ctx[], name[], size)">
			<stacksize value="5"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="OpcodeInsnInfo_name"/>
			<dependency name="strcat"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:DisasmGetNextIp" syntax="DisasmGetNextIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetNumOperands" syntax="DisasmGetNumOperands(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOpcode" syntax="DisasmGetOpcode(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<dependency name="DisasmContext_opcode"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOperand" syntax="DisasmGetOperand(ctx[], index)">
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="AMX_Read"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetOperandReloc" syntax="DisasmGetOperandReloc(ctx[], index)">
			<stacksize value="6"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNeedReloc"/>
			<dependency name="DisasmReloc"/>
			<dependency name="OP_CASETBL"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetRemaining" syntax="DisasmGetRemaining(ctx[])">
			<stacksize value="1"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmInit" syntax="DisasmInit(ctx[], start, end)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gCodBase"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:DisasmNeedReloc" syntax="DisasmNeedReloc(ctx[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="DisasmContext_insn"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNext" syntax="DisasmNext(ctx[])">
			<tagname value="DisasmResult"/>
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="NUM_OPCODES"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNextInsn" syntax="DisasmNextInsn(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="OP_NONE"/>
			<param name="ctx">
				<paraminfo> [22] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmReloc" syntax="DisasmReloc(addr)">
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="gCodBase"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:DisasmWrite" syntax="DisasmWrite(filename[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<referrer name="DisasmDump"/>
			<dependency name="DisasmWriteFile"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteCode" syntax="DisasmWriteCode(file)">
			<stacksize value="176"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetInsnName"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="gCodBase"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteData" syntax="DisasmWriteData(file)">
			<stacksize value="38"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="DisasmWriteDataRowChar"/>
			<dependency name="DisasmWriteDataRowHex"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="min"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteDataRowChar" syntax="DisasmWriteDataRowChar(file, start, num, max)">
			<stacksize value="13"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToPrintableAscii"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteDataRowHex" syntax="DisasmWriteDataRowHex(file, start, num, max)">
			<stacksize value="19"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteFile" syntax="DisasmWriteFile(file)">
			<stacksize value="4"/>
			<referrer name="DisasmWrite"/>
			<dependency name="DisasmWriteCode"/>
			<dependency name="DisasmWriteData"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DumpStack" syntax="DumpStack()">
			<stacksize value="9"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="print"/>
			<dependency name="printf"/>
		</member>
		<member name="M:F@" syntax="F@()">
			<stacksize value="6"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:G@" syntax="G@(...)">
			<stacksize value="1"/>
			<dependency name="G@"/>
			<dependency name="Q@"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:GRESKA" syntax="GRESKA()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="v"/>
			<referrer name="nvozilo"/>
		</member>
		<member name="M:GameTextForAll" syntax="GameTextForAll(string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForAll"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GameTextForPlayer" syntax="GameTextForPlayer(playerid, string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForPlayer"/>
			<param name="playerid">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GetAmxAddress" syntax="GetAmxAddress()">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="RunShellcode"/>
			<dependency name="refabs"/>
		</member>
		<member name="M:GetAmxBaseAddress" syntax="GetAmxBaseAddress()">
			<stacksize value="3"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="CodeScanInit"/>
			<referrer name="ProfilerInit"/>
			<referrer name="GetFunctionFromReturnAddress"/>
			<dependency name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxBaseAddressNow" syntax="GetAmxBaseAddressNow()">
			<stacksize value="9"/>
			<referrer name="GetAmxBaseAddress"/>
			<dependency name="GetAmxBaseAddress_helper"/>
		</member>
		<member name="M:GetAmxBaseAddress_helper" syntax="GetAmxBaseAddress_helper()">
			<stacksize value="1"/>
			<referrer name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxFrame" syntax="GetAmxFrame()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeader" syntax="GetAmxHeader(amxhdr[])">
			<stacksize value="3"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanInit"/>
			<referrer name="ProfilerInit"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderComponent" syntax="GetAmxHeaderComponent(comp)">
			<stacksize value="3"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="comp">
				<paraminfo>AMX_HDR </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderNow" syntax="GetAmxHeaderNow(amxhdr[])">
			<stacksize value="21"/>
			<referrer name="ResetStaticAmxHeader"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_AMX_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_CIP"/>
			<dependency name="AMX_HDR_OFFSET_COD"/>
			<dependency name="AMX_HDR_OFFSET_DAT"/>
			<dependency name="AMX_HDR_OFFSET_DEFSIZE"/>
			<dependency name="AMX_HDR_OFFSET_FILE_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_FLAGS"/>
			<dependency name="AMX_HDR_OFFSET_HEA"/>
			<dependency name="AMX_HDR_OFFSET_LIBRARIES"/>
			<dependency name="AMX_HDR_OFFSET_MAGIC"/>
			<dependency name="AMX_HDR_OFFSET_NAMETABLE"/>
			<dependency name="AMX_HDR_OFFSET_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_PUBLICS"/>
			<dependency name="AMX_HDR_OFFSET_PUBVARS"/>
			<dependency name="AMX_HDR_OFFSET_SIZE"/>
			<dependency name="AMX_HDR_OFFSET_STP"/>
			<dependency name="AMX_HDR_OFFSET_TAGS"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetRawAmxHeader"/>
			<dependency name="copy_1"/>
			<dependency name="copy_2"/>
			<dependency name="copy_4"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeapBase" syntax="GetAmxHeapBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeapTop" syntax="GetAmxHeapTop()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxJITBaseAddress" syntax="GetAmxJITBaseAddress()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxNextInstructionPointer" syntax="GetAmxNextInstructionPointer()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBase" syntax="GetAmxStackBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBottom" syntax="GetAmxStackBottom()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetCallerFrame" syntax="GetCallerFrame()">
			<stacksize value="1"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<referrer name="GetCurrentFrameParameter"/>
			<referrer name="GetCurrentFrameLocal"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<referrer name="SetCurrentFrameReturn"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<referrer name="SetCurrentParameterSize"/>
			<referrer name="SetCurrentParameterCount"/>
			<referrer name="GetCurrentFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrame" syntax="GetCurrentFrame()">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
		</member>
		<member name="M:GetCurrentFrameFunction" syntax="GetCurrentFrameFunction()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrameHeaderCount" syntax="GetCurrentFrameHeaderCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderCount"/>
		</member>
		<member name="M:GetCurrentFrameHeaderSize" syntax="GetCurrentFrameHeaderSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderSize"/>
		</member>
		<member name="M:GetCurrentFrameLocal" syntax="GetCurrentFrameLocal(param)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocal"/>
			<param name="param">
			</param>
		</member>
		<member name="M:GetCurrentFrameLocalCount" syntax="GetCurrentFrameLocalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalCount"/>
		</member>
		<member name="M:GetCurrentFrameLocalSize" syntax="GetCurrentFrameLocalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalSize"/>
		</member>
		<member name="M:GetCurrentFrameParameter" syntax="GetCurrentFrameParameter(param, idx)">
			<stacksize value="6"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameter"/>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetCurrentFrameParameterCount" syntax="GetCurrentFrameParameterCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterCount"/>
		</member>
		<member name="M:GetCurrentFrameParameterSize" syntax="GetCurrentFrameParameterSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterSize"/>
		</member>
		<member name="M:GetCurrentFramePreviousFrame" syntax="GetCurrentFramePreviousFrame()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFramePreviousFrame"/>
		</member>
		<member name="M:GetCurrentFrameReturn" syntax="GetCurrentFrameReturn()">
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="AMX_Read"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameReturn"/>
		</member>
		<member name="M:GetCurrentFrameTotalCount" syntax="GetCurrentFrameTotalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalCount"/>
		</member>
		<member name="M:GetCurrentFrameTotalSize" syntax="GetCurrentFrameTotalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalSize"/>
		</member>
		<member name="M:GetDat" syntax="GetDat()">
			<stacksize value="1"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
		</member>
		<member name="M:GetFrameFunction" syntax="GetFrameFunction(frm_addr)">
			<stacksize value="29"/>
			<referrer name="GetCurrentFrameFunction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="GetFrameVariable"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="UnrelocateOpcode"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderCount" syntax="GetFrameHeaderCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<dependency name="GetFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderSize" syntax="GetFrameHeaderSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameHeaderCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocal" syntax="GetFrameLocal(frm_addr, param)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameLocal"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
		</member>
		<member name="M:GetFrameLocalCount" syntax="GetFrameLocalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<dependency name="GetFrameLocalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocalSize" syntax="GetFrameLocalSize(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameNextFrame" syntax="GetFrameNextFrame(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameFunction"/>
			<dependency name="GetCurrentFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameter" syntax="GetFrameParameter(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameParameter"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFrameParameterCount" syntax="GetFrameParameterCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameterSize" syntax="GetFrameParameterSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameParameterCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFramePreviousFrame" syntax="GetFramePreviousFrame(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetStackTrace"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameReturn" syntax="GetFrameReturn(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetStackTrace"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalCount" syntax="GetFrameTotalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<dependency name="GetFrameTotalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalSize" syntax="GetFrameTotalSize(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetFrameTotalCount"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameVariable" syntax="GetFrameVariable(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFunctionFromReturnAddress" syntax="GetFunctionFromReturnAddress(ret_addr)">
			<stacksize value="4"/>
			<referrer name="PrintStackTrace"/>
			<dependency name="GetAmxBaseAddress"/>
			<param name="ret_addr">
			</param>
		</member>
		<member name="M:GetIP" syntax="GetIP(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				Player to get IP of.
			</param>
			  <returns>  IP as a 32bit int.  </returns> 
		</member>
		<member name="M:GetJITGeneratorVersion" syntax="GetJITGeneratorVersion()">
			<stacksize value="1"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
		</member>
		<member name="M:GetName" syntax="GetName()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnVehicleMod@001"/>
			<referrer name="@yH_OnVehicleSpawn@001"/>
			<referrer name="v"/>
		</member>
		<member name="M:GetNativeAddressFromIndex" syntax="GetNativeAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetNativeAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetNativeInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetNativeAddressFromName" syntax="GetNativeAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeIndexFromAddress" syntax="GetNativeIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetNativeIndexFromName" syntax="GetNativeIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeInfo" syntax="GetNativeInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeNameFromAddress" syntax="GetNativeNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNativeNameFromIndex" syntax="GetNativeNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetNativeInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNumNatives" syntax="GetNumNatives(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPubVars" syntax="GetNumPubVars(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPublics" syntax="GetNumPublics(amxhdr[])">
			<stacksize value="2"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTags" syntax="GetNumTags(amxhdr[])">
			<stacksize value="4"/>
			<dependency name="GetNumTagsInternal"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTagsInternal" syntax="GetNumTagsInternal(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNumTags"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetOS" syntax="GetOS()">
			<tagname value="OS"/>
			<stacksize value="4"/>
			<referrer name="IsWindows"/>
			<referrer name="IsLinux"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OS_LINUX"/>
			<dependency name="OS_UNKNOWN"/>
			<dependency name="OS_WINDOWS"/>
			<dependency name="RelocateOpcode"/>
		</member>
		<member name="M:GetOpcodeInstructionInformation" syntax="GetOpcodeInstructionInformation(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmDecodeInsn"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionName" syntax="GetOpcodeInstructionName(opcode)">
			<stacksize value="1"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionParameters" syntax="GetOpcodeInstructionParameters(opcode)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionRelocatable" syntax="GetOpcodeInstructionRelocatable(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<dependency name="false"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerFacingAngle" syntax="GetPlayerFacingAngle(playerid, &amp;ang)">
			<attribute name="native"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="nvozilo"/>
			<param name="playerid">
			</param>
			<param name="ang">
				<paraminfo>Float &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerIp" syntax="GetPlayerIp(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerName" syntax="GetPlayerName(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="ReturnPlayerName"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerPos" syntax="GetPlayerPos(playerid, &amp;x, &amp;y, &amp;z)">
			<attribute name="native"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="nvozilo"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerVehicleID" syntax="GetPlayerVehicleID(playerid)">
			<attribute name="native"/>
			<referrer name="nvozilo"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromIndex" syntax="GetPubVarAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPubVarInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromName" syntax="GetPubVarAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetPubVarAddressFromIndex"/>
			<dependency name="GetPubVarIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarIndexFromAddress" syntax="GetPubVarIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPubVarIndexFromName" syntax="GetPubVarIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarInfo" syntax="GetPubVarInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarNameFromAddress" syntax="GetPubVarNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPubVarIndexFromAddress"/>
			<dependency name="GetPubVarNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPubVarNameFromIndex" syntax="GetPubVarNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPubVarInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicAddressFromIndex" syntax="GetPublicAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPublicInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPublicAddressFromName" syntax="GetPublicAddressFromName(name[])">
			<stacksize value="4"/>
			<referrer name="AsmSetErrorHandlerName"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetPublicIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicIndexFromAddress" syntax="GetPublicIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPublicIndexFromName" syntax="GetPublicIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicInfo" syntax="GetPublicInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicNameFromAddress" syntax="GetPublicNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="PrintStackTrace"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicNameFromIndex" syntax="GetPublicNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="ProfilerWriteData"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPublicInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetRawAmxHeader" syntax="GetRawAmxHeader(plain_amxhdr[])">
			<stacksize value="6"/>
			<referrer name="GetAmxHeaderNow"/>
			<dependency name="ReadAmxMemory"/>
			<param name="plain_amxhdr">
				<paraminfo> [15] </paraminfo>
			</param>
		</member>
		<member name="M:GetStackTrace" syntax="GetStackTrace(trace[], skip, max)">
			<stacksize value="7"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<param name="trace">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="skip">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:GetTagIDFromIndex" syntax="GetTagIDFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetTagIDFromName" syntax="GetTagIDFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetTagIDFromIndex"/>
			<dependency name="GetTagIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIndexFromID" syntax="GetTagIndexFromID(id)">
			<stacksize value="7"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTagsInternal"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="id">
			</param>
		</member>
		<member name="M:GetTagIndexFromName" syntax="GetTagIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTagsInternal"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagInfo" syntax="GetTagInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTagsInternal"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagNameFromID" syntax="GetTagNameFromID(id, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetTagIndexFromID"/>
			<dependency name="GetTagNameFromIndex"/>
			<dependency name="true"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetTagNameFromIndex" syntax="GetTagNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetTagInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetVehicleComponentType" syntax="GetVehicleComponentType(component)">
			<attribute name="native"/>
			<referrer name="@yH_OnVehicleMod@001"/>
			<param name="component">
			</param>
		</member>
		<member name="M:GetVehicleName" syntax="GetVehicleName(modelid)">
			<stacksize value="26"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="@yH_OnPlayerStateChange@001"/>
			<referrer name="v"/>
			<referrer name="nvozilo"/>
			<dependency name="GetVehicleName"/>
			<dependency name="VehicleNames"/>
			<dependency name="VehicleNames"/>
			<dependency name="format"/>
			<param name="modelid">
			</param>
		</member>
		<member name="M:GetVehicleParamsEx" syntax="GetVehicleParamsEx(vehicleid, &amp;engine, &amp;lights, &amp;alarm, &amp;doors, &amp;bonnet, &amp;boot, &amp;objective)">
			<attribute name="native"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<param name="vehicleid">
			</param>
			<param name="engine">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="lights">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="alarm">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="doors">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="bonnet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="boot">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="objective">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:H@" syntax="H@(...)">
			<stacksize value="1"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:HaveToRelocateOpcodes" syntax="HaveToRelocateOpcodes()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_CALL"/>
			<dependency name="ReadOpcodeNearThis"/>
		</member>
		<member name="M:HeapAllocBytes" syntax="HeapAllocBytes(nbytes)">
			<stacksize value="2"/>
			<referrer name="HeapAllocCells"/>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:HeapAllocCells" syntax="HeapAllocCells(ncells)">
			<stacksize value="4"/>
			<dependency name="HeapAllocBytes"/>
			<param name="ncells">
			</param>
		</member>
		<member name="M:HeapRelease" syntax="HeapRelease(address)">
			<stacksize value="1"/>
			<param name="address">
			</param>
		</member>
		<member name="M:HookChain_OnScriptInit" syntax="HookChain_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="AMX_OnScriptInit"/>
		</member>
		<member name="M:HookNative" syntax="HookNative(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:HookPublic" syntax="HookPublic(index, address)">
			<stacksize value="8"/>
			<referrer name="ProfilerInit"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:Hooks_Collate" syntax="Hooks_Collate(preloads[][], precount, name[], idx)">
			<stacksize value="18"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_GenerateCode"/>
			<dependency name="Hooks_GetAllHooks"/>
			<dependency name="Hooks_GetPointerRewrite"/>
			<dependency name="Hooks_GetPreHooks"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
			</param>
			<param name="precount">
			</param>
			<param name="name">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:Hooks_CompareNextCell" syntax="Hooks_CompareNextCell(addr0, addr1)">
			<stacksize value="6"/>
			<referrer name="Hooks_ComparePublics"/>
			<dependency name="AMX_Read"/>
			<dependency name="Cell_ReverseBytes"/>
			<param name="addr0">
				The 1st address to read.
			</param>
			<param name="addr1">
				The 2nd address to read.
			</param>
			    <returns>  -1 - The first address is bigger.  0  - The addresses are the same  1  - The second address is bigger.  </returns>  <remarks>  Reads two addresses, converts them to big endian, and compares them as four  characters of a string at once.  </remarks> 
		</member>
		<member name="M:Hooks_ComparePublics" syntax="Hooks_ComparePublics(idx0, idx1)">
			<stacksize value="9"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_CompareNextCell"/>
			<param name="idx0">
				The index of the 1st public.
			</param>
			<param name="idx1">
				The index of the 2nd public.
			</param>
			    <remarks>  Compares two public function entries, and if need-be, swaps them over.  </remarks> 
		</member>
		<member name="M:Hooks_CountInvalidPublics" syntax="Hooks_CountInvalidPublics()">
			<stacksize value="10"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<remarks>  Counts the number of public functions that have had their names erased.  </remarks> 
		</member>
		<member name="M:Hooks_DoAllHooks" syntax="Hooks_DoAllHooks()">
			<stacksize value="185"/>
			<referrer name="AMX_OnScriptInit"/>
			<dependency name="AMX_GetNamePrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_PRE_HOOK"/>
			<dependency name="Hooks_Collate"/>
			<dependency name="Hooks_GetPreloadLibraries"/>
			<dependency name="Hooks_SortPublics"/>
		</member>
		<member name="M:Hooks_GenerateCode" syntax="Hooks_GenerateCode(name[], hooks[], count, write, hasprehooks)">
			<stacksize value="7"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="Hooks_GetDefaultReturn"/>
			<dependency name="Hooks_WriteFunction"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the function to generate.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the functions to call.
			</param>
			<param name="count">
				Number of functions to call.
			</param>
			<param name="write">
				Where to write the new function's pointer.
			</param>
			<param name="hasprehooks">
				<paraminfo>bool </paraminfo>
				Needs to call other stuff first.
			</param>
			         
		</member>
		<member name="M:Hooks_GetAllHooks" syntax="Hooks_GetAllHooks(name[], hooks[], idx, &amp;namelen)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_GetStringFromEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback (with y_hooks prefix).
			</param>
			<param name="hooks">
				<paraminfo> [128] </paraminfo>
				Array in which to store the function headers.
			</param>
			<param name="idx">
				Current position in the AMX header.
			</param>
			<param name="namelen">
				<paraminfo> &amp; </paraminfo>
				Min bound of space used by all these names.
			</param>
			        <returns>  The number of hooks found.  </returns>  <remarks>  The name of the function currently being processed is derived from the first  found hook.  This means we already know of one hook, but to simplify the  code we get that one again here.  Above we only know the name not the  address.  Hence the "- 1" in "i = idx - 1" (to go back one function name).  Our "namelen" variable already contains the full length of the first found  hook - this is the length of "name", plus N extra characters.  The following  are all valid, and may occur when orders are played with:  @yH_OnX@  @yH_OnX@1  @yH_OnX@01  @yH_OnX@024  @yH_OnX@ZZZ  @yH_OnX@999@024  If we want to get the EXACT space taken up by all these hook names we would  need to get the string of the name in this function then measure it.  There  is really no point in doing this - if we have a second we will always have  enough space for our new names.  Instead, we assume that they are all just  @yH_OnX@  And add on that minimum length accordingly (plus 1 for the NULL character).  This length is used if the original callback doesn't exist but hooks do.  In  that case we need to add the callback to the AMX header, and there is a tiny  chance that the original name will be longer than one hook's name.  In that  case, having two or more hooks will (AFAIK) always ensure that we have  enough space to write the longer name.  If there is only one hook, no original function, and the name of the hook is  shorter than the name of the original function then we have an issue and  will have to do something else instead.  </remarks> 
		</member>
		<member name="M:Hooks_GetDefaultReturn" syntax="Hooks_GetDefaultReturn(name[])">
			<stacksize value="9"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strins"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				The function to get the default return of.
			</param>
			  <returns>  The default return for a callback, normally 1.  </returns> 
		</member>
		<member name="M:Hooks_GetFunctionWritePoint" syntax="Hooks_GetFunctionWritePoint(name[], &amp;write)">
			<stacksize value="8"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The function to get the address pointer of.
			</param>
			<param name="write">
				<paraminfo> &amp; </paraminfo>
				Destination variable.
			</param>
			    <returns>  The address at which this function's pointer is stored in the AMX header, if  the function exists of course.  </returns> 
		</member>
		<member name="M:Hooks_GetPointerRewrite" syntax="Hooks_GetPointerRewrite(hooks[], num, &amp;ptr, &amp;next, name[], nlen)">
			<stacksize value="39"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AMX_WriteString"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_GetStubEntry"/>
			<dependency name="OP_JUMP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the prehooks for this callback.
			</param>
			<param name="num">
				The number of prehooks.
			</param>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				A pointer to write the new stub address to.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				The pointer for the function called after y_hooks.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback being processed.
			</param>
			<param name="nlen">
				Space available in the header to write text in.
			</param>
			           
		</member>
		<member name="M:Hooks_GetPreHooks" syntax="Hooks_GetPreHooks(preloads[][], precount, name[], hooks[], &amp;count)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_PRE_HOOK_NAME"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Names of libraries that come before y_hooks.
			</param>
			<param name="precount">
				Number of pre libraries.
			</param>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the callback.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Destination in which to store the headers.
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of headers found.
			</param>
			          <remarks>  Finds all the AMX file headers for functions with a similar name to the  given callback that should be called before (or near) the given callback.  </remarks> 
		</member>
		<member name="M:Hooks_GetPreloadLibraries" syntax="Hooks_GetPreloadLibraries(preloads[][], &amp;precount, size)">
			<stacksize value="20"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_PRE_HOOK"/>
			<dependency name="E_PRE_HOOK_NAME"/>
			<dependency name="E_PRE_HOOK_VALUE"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Desination in which to store all the preloads.
			</param>
			<param name="precount">
				<paraminfo> &amp; </paraminfo>
				Number of found preload libraries.
			</param>
			<param name="size">
				Maximum number of libraries to store.
			</param>
			      <remarks>  Some includes, like "fixes.inc" and anti-cheats MUST come before all other  includes in order for everything to function correctly (at least fixes.inc  must).  This function looks for these definitions:  PRE_HOOK(FIXES)  Which tell y_hooks that any "FIXES_" prefixed callbacks are part of one of  these chains.  </remarks> 
		</member>
		<member name="M:Hooks_GetStubEntry" syntax="Hooks_GetStubEntry(stub)">
			<stacksize value="30"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SWITCH"/>
			<param name="stub">
				Starting address of the function.
			</param>
			  <returns>  The address at which the actual code in this function starts.  </returns>  <remarks>  This handles three cases.  Regular functions end instantly as found.  Functions that start with a switch (even before "PROC") are assumed to be  state-based functions, and we find the most likely state to be used (i.e. we  remove all future state changes).  </remarks> 
		</member>
		<member name="M:Hooks_InvalidateName" syntax="Hooks_InvalidateName(entry)">
			<stacksize value="5"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="AMX_OnScriptInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<param name="entry">
				The public function slot to destroy.
			</param>
			  <remarks>  Basically, once we know a function has been included, wipe it from the AMX  header.  </remarks> 
		</member>
		<member name="M:Hooks_IsolateName" syntax="Hooks_IsolateName(name[])">
			<stacksize value="138"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="Debug_Print0"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The string to get the hooked function name from.
			</param>
			  <returns>  The input string without y_hooks name decorations.  </returns> 
		</member>
		<member name="M:Hooks_MakeLongName" syntax="Hooks_MakeLongName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Expands all name parts like "CP" and "Obj" to their full versions (in this  example "Checkpoint" and "Object").  </remarks> 
		</member>
		<member name="M:Hooks_MakeShortName" syntax="Hooks_MakeShortName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Compresses function names when required to fit within 32 characters  according to well defined rules (see "YSI_g_sReplacements").  </remarks> 
		</member>
		<member name="M:Hooks_NumArgs" syntax="Hooks_NumArgs()">
			<stacksize value="1"/>
		</member>
		<member name="M:Hooks_SortPublics" syntax="Hooks_SortPublics()">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_ComparePublics"/>
			<dependency name="Hooks_CountInvalidPublics"/>
			<dependency name="ResetStaticAmxHeader"/>
			<remarks>  Goes through the whole of the public functions table and sorts them all in  to alphabetical order.  This is done as we move and rename some so we need  to fix the virtual machine's binary search.  </remarks> 
		</member>
		<member name="M:Hooks_SortReplacements" syntax="Hooks_SortReplacements()">
			<stacksize value="6"/>
			<referrer name="AMX_OnScriptInit"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<remarks>  Once all the replacement strings have been found, sort them by the length of  the short versions of the strings.  This is so that the longest (and special  case, e.g. "DynamicCP"-> "DynamicCP") replacements are always done first.  </remarks> 
		</member>
		<member name="M:Hooks_WriteFunction" syntax="Hooks_WriteFunction(pointers[], size, ret, skipable)">
			<stacksize value="29"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitCall"/>
			<dependency name="AsmEmitInvert"/>
			<dependency name="AsmEmitJsgeqRel"/>
			<dependency name="AsmEmitJslessRel"/>
			<dependency name="AsmEmitJumpRel"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitOr"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSub"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmEmitZeroAlt"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="Debug_Print0"/>
			<param name="pointers">
				<paraminfo> [] </paraminfo>
				The hooks to link together.
			</param>
			<param name="size">
				The number of functions in the array.
			</param>
			<param name="ret">
				The default return.
			</param>
			<param name="skipable">
				Can future hooks be ignored on -1?
			</param>
			        <returns>  The number of bytes written to memory.  </returns>  <remarks>  Generate some new code, very nicely :D.  </remarks> 
		</member>
		<member name="M:INI_Close" syntax="INI_Close()">
			<stacksize value="1"/>
			<referrer name="SacuvajVozilo"/>
		</member>
		<member name="M:INI_Float" syntax="INI_Float(VI[][])">
			<stacksize value="1"/>
			<param name="VI">
				<paraminfo> [][46] </paraminfo>
			</param>
		</member>
		<member name="M:INI_Int" syntax="INI_Int(VI[][])">
			<stacksize value="1"/>
			<param name="VI">
				<paraminfo> [][1] </paraminfo>
			</param>
		</member>
		<member name="M:INI_Open" syntax="INI_Open()">
			<stacksize value="1"/>
			<referrer name="SacuvajVozilo"/>
		</member>
		<member name="M:INI_ParseFile" syntax="INI_ParseFile()">
			<stacksize value="1"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
		</member>
		<member name="M:INI_String" syntax="INI_String(VI[][])">
			<stacksize value="1"/>
			<param name="VI">
				<paraminfo> [][2] </paraminfo>
			</param>
		</member>
		<member name="M:INI_WriteFloat" syntax="INI_WriteFloat()">
			<stacksize value="1"/>
			<referrer name="SacuvajVozilo"/>
		</member>
		<member name="M:INI_WriteInt" syntax="INI_WriteInt()">
			<stacksize value="1"/>
			<referrer name="SacuvajVozilo"/>
		</member>
		<member name="M:INI_WriteString" syntax="INI_WriteString()">
			<stacksize value="1"/>
			<referrer name="SacuvajVozilo"/>
		</member>
		<member name="M:IPToInt" syntax="IPToInt(ip[])">
			<stacksize value="5"/>
			<referrer name="OnPlayerConnect"/>
			<dependency name="strval"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				Dot notation IP to convert to an integer.
			</param>
			 
		</member>
		<member name="M:IS_IN_RANGE" syntax="IS_IN_RANGE(lower, value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="lower">
				The lower limit.
			</param>
			<param name="value">
				The number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value in the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:InitOpcodeTable" syntax="InitOpcodeTable()">
			<stacksize value="5"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="RelocateOpcodeNow"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<dependency name="true"/>
		</member>
		<member name="M:InterpolateColour" syntax="InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue)">
			<stacksize value="3"/>
			<param name="startcolor">
				One of the two colours.
			</param>
			<param name="endcolor">
				The other of the two colours.
			</param>
			<param name="value">
				The interpolation value between the endpoints.
			</param>
			<param name="maxvalue">
				One of the two numbers.
			</param>
			<param name="minvalue">
				The other of the two numbers.
			</param>
			<summary>  InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue = 0);  </summary>            <remarks>  This function takes two endpoint values (minvalue and maxvalue, with  minvalue defaulting to 0), along with a third value (value) whose distance  between the two endpoints is calculated (as a percentage).  This percentage  value is then applied to the two colours given to find a third colour at  some point between those two colours.  For example, if the endpoints given are "0" and "10", and the value given is  "3", then that is "30%" of the way between the two endpoints.  We therefore  want to find a colour that is 30% of the way between the two given colours.  </remarks> 
		</member>
		<member name="M:IsLinux" syntax="IsLinux()">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<dependency name="GetOS"/>
			<dependency name="OS_LINUX"/>
		</member>
		<member name="M:IsOpcodeValid" syntax="IsOpcodeValid(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerInAnyVehicle" syntax="IsPlayerInAnyVehicle(playerid)">
			<attribute name="native"/>
			<referrer name="nvozilo"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPlayerInVehicle" syntax="IsPlayerInVehicle(playerid, vehicleid)">
			<attribute name="native"/>
			<referrer name="@yH_OnVehicleMod@001"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:IsPrintableAscii" syntax="IsPrintableAscii(c)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="ToPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:IsTagIDEmpty" syntax="IsTagIDEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDStrong" syntax="IsTagIDStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDWeak" syntax="IsTagIDWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexEmpty" syntax="IsTagIndexEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexStrong" syntax="IsTagIndexStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexWeak" syntax="IsTagIndexWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagNameEmpty" syntax="IsTagNameEmpty(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameStrong" syntax="IsTagNameStrong(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameWeak" syntax="IsTagNameWeak(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsWindows" syntax="IsWindows()">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<dependency name="GetOS"/>
			<dependency name="OS_WINDOWS"/>
		</member>
		<member name="M:Iter_Func@Bits" syntax="Iter_Func@Bits(start, data[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Blanks" syntax="Iter_Func@Blanks(start, data[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:KORISTI" syntax="KORISTI()">
			<stacksize value="1"/>
			<referrer name="nvozilo"/>
		</member>
		<member name="M:Mean" syntax="Mean(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Sum"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical mean value of the array.  </returns> 
		</member>
		<member name="M:Median" syntax="Median(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical median value of the array.  </returns> 
		</member>
		<member name="M:Mode" syntax="Mode(arr[], num)">
			<stacksize value="6"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical modal value of the array.  </returns> 
		</member>
		<member name="M:NOT_IN_RANGE" syntax="NOT_IN_RANGE(lower, value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="lower">
				The lower limit.
			</param>
			<param name="value">
				The number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value outside the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:NovacMinus" syntax="NovacMinus()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
		</member>
		<member name="M:NtCompare" syntax="NtCompare(s1, s2[])">
			<stacksize value="8"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetTagIndexFromName"/>
			<dependency name="ReadAmxMemory"/>
			<param name="s1">
			</param>
			<param name="s2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:NtCopy" syntax="NtCopy(src, dest[], size)">
			<stacksize value="6"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ReadAmxMemory"/>
			<param name="src">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:O@A_" syntax="O@A_()">
			<tagname value="bool"/>
			<stacksize value="28"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
		</member>
		<member name="M:OnActorStreamIn" syntax="OnActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnActorStreamOut" syntax="OnActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDialogResponse" syntax="OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnEnterExitModShop" syntax="OnEnterExitModShop(playerid, enterexit, interiorid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="enterexit">
			</param>
			<param name="interiorid">
			</param>
		</member>
		<member name="M:OnFilterScriptExit" syntax="OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnFilterScriptInit" syntax="OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptInit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="true"/>
			<transition keep="true" target="_script_init_fix_state : true"/>  <transition keep="true" target="_ALS : _ALS_go"/> 
		</member>
		<member name="M:OnGameModeExit" syntax="OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnGameModeInit" syntax="OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeInit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<transition keep="true" target="_script_init_fix_state : false"/>  <transition keep="true" target="_ALS : _ALS_go"/> 
		</member>
		<member name="M:OnIncomingConnection" syntax="OnIncomingConnection(playerid, ip_address[], port)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="ip_address">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="port">
			</param>
		</member>
		<member name="M:OnObjectMoved" syntax="OnObjectMoved(objectid)">
			<stacksize value="1"/>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerClickMap" syntax="OnPlayerClickMap(playerid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickPlayer" syntax="OnPlayerClickPlayer(playerid, clickedplayerid, source)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedplayerid">
			</param>
			<param name="source">
			</param>
		</member>
		<member name="M:OnPlayerClickPlayerTextDraw" syntax="OnPlayerClickPlayerTextDraw(playerid, playertextid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playertextid">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickTextDraw" syntax="OnPlayerClickTextDraw(playerid, clickedid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedid">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandText" syntax="OnPlayerCommandText(playerid, cmdtext[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerConnect" syntax="OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="21"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="IPToInt"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerDeath" syntax="OnPlayerDeath(playerid, killerid, reason)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="killerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerDisconnect" syntax="OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerEditAttachedObject" syntax="OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="response">
			</param>
			<param name="index">
			</param>
			<param name="modelid">
			</param>
			<param name="boneid">
			</param>
			<param name="fOffsetX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEditObject" syntax="OnPlayerEditObject(playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playerobject">
			</param>
			<param name="objectid">
			</param>
			<param name="response">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEnterCheckpoint" syntax="OnPlayerEnterCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterRaceCheckpoint" syntax="OnPlayerEnterRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterVehicle" syntax="OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="ispassenger">
			</param>
		</member>
		<member name="M:OnPlayerExitVehicle" syntax="OnPlayerExitVehicle(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnPlayerExitedMenu" syntax="OnPlayerExitedMenu(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamage" syntax="OnPlayerGiveDamage(playerid, damagedid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damagedid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamageActor" syntax="OnPlayerGiveDamageActor(playerid, damaged_actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damaged_actorid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerInteriorChange" syntax="OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newinteriorid">
			</param>
			<param name="oldinteriorid">
			</param>
		</member>
		<member name="M:OnPlayerKeyStateChange" syntax="OnPlayerKeyStateChange(playerid, newkeys, oldkeys)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:OnPlayerLeaveCheckpoint" syntax="OnPlayerLeaveCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveRaceCheckpoint" syntax="OnPlayerLeaveRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerObjectMoved" syntax="OnPlayerObjectMoved(playerid, objectid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerPickUpPickup" syntax="OnPlayerPickUpPickup(playerid, pickupid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="pickupid">
			</param>
		</member>
		<member name="M:OnPlayerRequestClass" syntax="OnPlayerRequestClass(playerid, classid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="classid">
			</param>
		</member>
		<member name="M:OnPlayerRequestSpawn" syntax="OnPlayerRequestSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerSelectObject" syntax="OnPlayerSelectObject(playerid, type, objectid, modelid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="type">
			</param>
			<param name="objectid">
			</param>
			<param name="modelid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSelectedMenuRow" syntax="OnPlayerSelectedMenuRow(playerid, row)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="row">
			</param>
		</member>
		<member name="M:OnPlayerSpawn" syntax="OnPlayerSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerStateChange" syntax="OnPlayerStateChange(playerid, newstate, oldstate)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newstate">
			</param>
			<param name="oldstate">
			</param>
		</member>
		<member name="M:OnPlayerStreamIn" syntax="OnPlayerStreamIn(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerStreamOut" syntax="OnPlayerStreamOut(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerTakeDamage" syntax="OnPlayerTakeDamage(playerid, issuerid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="issuerid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerText" syntax="OnPlayerText(playerid, text[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerUpdate" syntax="OnPlayerUpdate(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerWeaponShot" syntax="OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="weaponid">
			</param>
			<param name="hittype">
			</param>
			<param name="hitid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnRconCommand" syntax="OnRconCommand(cmd[])">
			<stacksize value="1"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnRconLoginAttempt" syntax="OnRconLoginAttempt(ip[], password[], success)">
			<stacksize value="1"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
			</param>
		</member>
		<member name="M:OnTrailerUpdate" syntax="OnTrailerUpdate(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnUnoccupiedVehicleUpdate" syntax="OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, new_x, new_y, new_z, vel_x, vel_y, vel_z)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
			<param name="passenger_seat">
			</param>
			<param name="new_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnVehicleDamageStatusUpdate" syntax="OnVehicleDamageStatusUpdate(vehicleid, playerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnVehicleDeath" syntax="OnVehicleDeath(vehicleid, killerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="killerid">
			</param>
		</member>
		<member name="M:OnVehicleMod" syntax="OnVehicleMod(playerid, vehicleid, componentid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="componentid">
			</param>
		</member>
		<member name="M:OnVehiclePaintjob" syntax="OnVehiclePaintjob(playerid, vehicleid, paintjobid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="paintjobid">
			</param>
		</member>
		<member name="M:OnVehicleRespray" syntax="OnVehicleRespray(playerid, vehicleid, color1, color2)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:OnVehicleSirenStateChange" syntax="OnVehicleSirenStateChange(playerid, vehicleid, newstate)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="newstate">
			</param>
		</member>
		<member name="M:OnVehicleSpawn" syntax="OnVehicleSpawn(vehicleid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnVehicleStreamIn" syntax="OnVehicleStreamIn(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnVehicleStreamOut" syntax="OnVehicleStreamOut(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:Pop" syntax="Pop(&amp;arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:PrintAmxHeader" syntax="PrintAmxHeader()">
			<stacksize value="4"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="printf"/>
		</member>
		<member name="M:PrintStackTrace" syntax="PrintStackTrace(trace[], max)">
			<stacksize value="40"/>
			<dependency name="GetFunctionFromReturnAddress"/>
			<dependency name="GetPublicNameFromAddress"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<param name="trace">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:ProfilerInit" syntax="ProfilerInit()">
			<stacksize value="31"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="HookPublic"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_pecs"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="new_pec"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="printf"/>
		</member>
		<member name="M:ProfilerWriteData" syntax="ProfilerWriteData(filename[])">
			<tagname value="bool"/>
			<stacksize value="144"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="format"/>
			<dependency name="fwrite"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="io_write"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Push" syntax="Push(arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="PushString"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:PushString" syntax="PushString(string[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<dependency name="Push"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:R@" syntax="R@(buffer[])">
			<stacksize value="6"/>
			<dependency name="setproperty"/>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Random" syntax="Random(min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="min">
			</param>
			<param name="max">
				Upper bound.
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>    <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default minimum is 0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:RandomFloat" syntax="RandomFloat(min, max, dp)">
			<tagname value="Float"/>
			<stacksize value="5"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="float"/>
			<dependency name="floatpower"/>
			<dependency name="floatround"/>
			<dependency name="random"/>
			<param name="min">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="max">
				<paraminfo>Float </paraminfo>
				Upper bound.
			</param>
			<param name="dp">
				How small to make the differences
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>      <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default  minimum is 0.0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:Range" syntax="Range(arr[], num)">
			<stacksize value="4"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical range of the values of the array.  </returns> 
		</member>
		<member name="M:ReadAmxCell" syntax="ReadAmxCell(offset)">
			<stacksize value="5"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="ReadPhysMemoryCell"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadAmxMemory" syntax="ReadAmxMemory(address)">
			<stacksize value="1"/>
			<referrer name="ReadAmxMemoryArray"/>
			<referrer name="GetRawAmxHeader"/>
			<referrer name="NtCompare"/>
			<referrer name="NtCopy"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetOperand"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="DumpStack"/>
			<referrer name="YVA2_FoundCall"/>
			<param name="address">
			</param>
		</member>
		<member name="M:ReadAmxMemoryArray" syntax="ReadAmxMemoryArray(address, values[], size)">
			<stacksize value="5"/>
			<dependency name="ReadAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:ReadOpcodeNearThis" syntax="ReadOpcodeNearThis(offset)">
			<tagname value="Opcode"/>
			<stacksize value="2"/>
			<referrer name="HaveToRelocateOpcodes"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_NONE"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadPhysMemory" syntax="ReadPhysMemory(address, dest[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:ReadPhysMemoryCell" syntax="ReadPhysMemoryCell(address)">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelToAbs" syntax="RelToAbs(address)">
			<stacksize value="3"/>
			<referrer name="refabs"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelocateOpcode" syntax="RelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetOS"/>
			<referrer name="new_pec"/>
			<referrer name="YVA2_CodeGenShiftCode"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:RelocateOpcodeNow" syntax="RelocateOpcodeNow(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="5"/>
			<referrer name="RelocateOpcodeNow"/>
			<referrer name="InitOpcodeTable"/>
			<dependency name="HaveToRelocateOpcodes"/>
			<dependency name="OP_ADD"/>
			<dependency name="OP_ADDR_ALT"/>
			<dependency name="OP_ADDR_PRI"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_ALIGN_ALT"/>
			<dependency name="OP_ALIGN_PRI"/>
			<dependency name="OP_AND"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_CMPS"/>
			<dependency name="OP_CONST_ALT"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_DEC"/>
			<dependency name="OP_DEC_ALT"/>
			<dependency name="OP_DEC_I"/>
			<dependency name="OP_DEC_PRI"/>
			<dependency name="OP_DEC_S"/>
			<dependency name="OP_EQ"/>
			<dependency name="OP_EQ_C_ALT"/>
			<dependency name="OP_EQ_C_PRI"/>
			<dependency name="OP_FILL"/>
			<dependency name="OP_GEQ"/>
			<dependency name="OP_GRTR"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_IDXADDR"/>
			<dependency name="OP_IDXADDR_B"/>
			<dependency name="OP_INC"/>
			<dependency name="OP_INC_ALT"/>
			<dependency name="OP_INC_I"/>
			<dependency name="OP_INC_PRI"/>
			<dependency name="OP_INC_S"/>
			<dependency name="OP_INVERT"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LEQ"/>
			<dependency name="OP_LESS"/>
			<dependency name="OP_LIDX"/>
			<dependency name="OP_LIDX_B"/>
			<dependency name="OP_LOAD_ALT"/>
			<dependency name="OP_LOAD_I"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_LODB_I"/>
			<dependency name="OP_LREF_ALT"/>
			<dependency name="OP_LREF_PRI"/>
			<dependency name="OP_LREF_S_ALT"/>
			<dependency name="OP_LREF_S_PRI"/>
			<dependency name="OP_MOVE_ALT"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_MOVS"/>
			<dependency name="OP_NEG"/>
			<dependency name="OP_NEQ"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_NOT"/>
			<dependency name="OP_OR"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_RET"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_SDIV"/>
			<dependency name="OP_SDIV_ALT"/>
			<dependency name="OP_SGEQ"/>
			<dependency name="OP_SGRTR"/>
			<dependency name="OP_SHL"/>
			<dependency name="OP_SHL_C_ALT"/>
			<dependency name="OP_SHL_C_PRI"/>
			<dependency name="OP_SHR"/>
			<dependency name="OP_SHR_C_ALT"/>
			<dependency name="OP_SHR_C_PRI"/>
			<dependency name="OP_SIGN_ALT"/>
			<dependency name="OP_SIGN_PRI"/>
			<dependency name="OP_SLEQ"/>
			<dependency name="OP_SLESS"/>
			<dependency name="OP_SMUL"/>
			<dependency name="OP_SMUL_C"/>
			<dependency name="OP_SREF_ALT"/>
			<dependency name="OP_SREF_PRI"/>
			<dependency name="OP_SREF_S_ALT"/>
			<dependency name="OP_SREF_S_PRI"/>
			<dependency name="OP_SSHR"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_ALT"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_STOR_PRI"/>
			<dependency name="OP_STOR_S_ALT"/>
			<dependency name="OP_STOR_S_PRI"/>
			<dependency name="OP_STRB_I"/>
			<dependency name="OP_SUB"/>
			<dependency name="OP_SUB_ALT"/>
			<dependency name="OP_SWAP_ALT"/>
			<dependency name="OP_SWAP_PRI"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="OP_UDIV"/>
			<dependency name="OP_UDIV_ALT"/>
			<dependency name="OP_UMUL"/>
			<dependency name="OP_XCHG"/>
			<dependency name="OP_XOR"/>
			<dependency name="OP_ZERO"/>
			<dependency name="OP_ZERO_ALT"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="OP_ZERO_S"/>
			<dependency name="ReadOpcodeNearThis"/>
			<dependency name="debug"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:ResetStaticAmxHeader" syntax="ResetStaticAmxHeader()">
			<stacksize value="4"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="GetAmxHeaderNow"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
		</member>
		<member name="M:ResolveJITAddress" syntax="ResolveJITAddress(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:ReturnPlayerName" syntax="ReturnPlayerName(playerid)">
			<stacksize value="29"/>
			<dependency name="GetPlayerName"/>
			<dependency name="ReturnPlayerName"/>
			<param name="playerid">
				Player whose name you want to get.
			</param>
			<summary>  ReturnPlayerName  </summary>    <remarks>  Now uses a global array to avoid repeated function calls.  Actually doesn't  because that causes issues with multiple scripts.  </remarks> 
		</member>
		<member name="M:RunShellcode" syntax="RunShellcode(code_ptr, align)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="SysreqD"/>
			<param name="code_ptr">
			</param>
			<param name="align">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:S@" syntax="S@(v)">
			<stacksize value="6"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<dependency name="strunpack"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:SCM" syntax="SCM()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="nvozilo"/>
		</member>
		<member name="M:SPD" syntax="SPD()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnPlayerStateChange@001"/>
			<referrer name="v"/>
		</member>
		<member name="M:SacuvajVozilo" syntax="SacuvajVozilo(id)">
			<stacksize value="136"/>
			<referrer name="@yH_OnGameScriptExit@001"/>
			<dependency name="Boja1"/>
			<dependency name="Boja2"/>
			<dependency name="INI_Close"/>
			<dependency name="INI_Open"/>
			<dependency name="INI_WriteFloat"/>
			<dependency name="INI_WriteInt"/>
			<dependency name="INI_WriteString"/>
			<dependency name="Mod"/>
			<dependency name="Model"/>
			<dependency name="PosA"/>
			<dependency name="PosX"/>
			<dependency name="PosY"/>
			<dependency name="PosZ"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="Zakljucan"/>
			<dependency name="format"/>
			<dependency name="vImeVlasnika"/>
			<param name="id">
			</param>
		</member>
		<member name="M:ScriptInit_OnFilterScriptExit" syntax="ScriptInit_OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
		</member>
		<member name="M:ScriptInit_OnFilterScriptInit" syntax="ScriptInit_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptInit"/>
		</member>
		<member name="M:ScriptInit_OnGameModeExit" syntax="ScriptInit_OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnGameModeInit" syntax="ScriptInit_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeInit"/>
		</member>
		<member name="M:ScriptInit_OnScriptExit" syntax="ScriptInit_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnScriptInit" syntax="ScriptInit_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="print"/>
		</member>
		<member name="M:SendClientMessage" syntax="SendClientMessage(playerid, color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessage"/>
			<param name="playerid">
			</param>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendClientMessageToAll" syntax="SendClientMessageToAll(color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessageToAll"/>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToAll" syntax="SendPlayerMessageToAll(senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToPlayer" syntax="SendPlayerMessageToPlayer(playerid, senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SetAmxFrame" syntax="SetAmxFrame(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxHeapTop" syntax="SetAmxHeapTop(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxNextInstructionPointer" syntax="SetAmxNextInstructionPointer(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxStackBottom" syntax="SetAmxStackBottom(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetCurrentFramePreviousFrame" syntax="SetCurrentFramePreviousFrame(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFramePreviousFrame"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentFrameReturn" syntax="SetCurrentFrameReturn(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameReturn"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentParameterCount" syntax="SetCurrentParameterCount(count)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterCount"/>
			<param name="count">
			</param>
		</member>
		<member name="M:SetCurrentParameterSize" syntax="SetCurrentParameterSize(size)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFrameLocal" syntax="SetFrameLocal(frm_addr, param, value)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:SetFrameParameter" syntax="SetFrameParameter(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetFrameParameterCount" syntax="SetFrameParameterCount(frm_addr, count)">
			<stacksize value="5"/>
			<referrer name="SetCurrentParameterCount"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="count">
			</param>
		</member>
		<member name="M:SetFrameParameterSize" syntax="SetFrameParameterSize(frm_addr, size)">
			<stacksize value="1"/>
			<referrer name="SetFrameParameterCount"/>
			<referrer name="SetCurrentParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFramePreviousFrame" syntax="SetFramePreviousFrame(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameReturn" syntax="SetFrameReturn(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFrameReturn"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameVariable" syntax="SetFrameVariable(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetPlayerPos" syntax="SetPlayerPos(playerid, x, y, z)">
			<attribute name="native"/>
			<referrer name="nvozilo"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetTimerEx" syntax="SetTimerEx(funcname[], interval, repeating, format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="_@_y_cgen_@_0"/>
			<param name="funcname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="repeating">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:SetVehicleParamsEx" syntax="SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective)">
			<attribute name="native"/>
			<referrer name="nvozilo"/>
			<param name="vehicleid">
			</param>
			<param name="engine">
			</param>
			<param name="lights">
			</param>
			<param name="alarm">
			</param>
			<param name="doors">
			</param>
			<param name="bonnet">
			</param>
			<param name="boot">
			</param>
			<param name="objective">
			</param>
		</member>
		<member name="M:SetVehicleParamsForPlayer" syntax="SetVehicleParamsForPlayer(vehicleid, playerid, objective, doorslocked)">
			<attribute name="native"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
			<param name="objective">
			</param>
			<param name="doorslocked">
			</param>
		</member>
		<member name="M:SetVehicleToRespawn" syntax="SetVehicleToRespawn(vehicleid)">
			<attribute name="native"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:SkipWhitespace" syntax="SkipWhitespace(str[], pos)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to skip over part of.
			</param>
			<param name="pos">
				The start of the whitespace.
			</param>
			    <returns>  The end of the whitespace.  </returns>  <remarks>  Doesn't skip over NULL terminators.  </remarks> 
		</member>
		<member name="M:SledeciIDVozila" syntax="SledeciIDVozila()">
			<stacksize value="87"/>
			<referrer name="nvozilo"/>
			<dependency name="fexist"/>
			<dependency name="format"/>
		</member>
		<member name="M:StrToLower" syntax="StrToLower(str[], len)">
			<stacksize value="5"/>
			<dependency name="tolower"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:StrToUpper" syntax="StrToUpper(str[], len)">
			<stacksize value="5"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:Strip" syntax="Strip(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start and end of.
			</param>
			 
		</member>
		<member name="M:StripL" syntax="StripL(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start of.
			</param>
			 
		</member>
		<member name="M:StripNL" syntax="StripNL(str[])">
			<stacksize value="4"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the end of.
			</param>
			  <remarks>  Updated from old versions, should be more efficient  </remarks> 
		</member>
		<member name="M:Sum" syntax="Sum(arr[], num)">
			<stacksize value="2"/>
			<referrer name="Mean"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need summing.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  All the values in the array added together.  </returns> 
		</member>
		<member name="M:SysreqC" syntax="SysreqC(index, auto_pop)">
			<stacksize value="9"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqCN" syntax="SysreqCN(index, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqD" syntax="SysreqD(address, auto_pop)">
			<stacksize value="9"/>
			<referrer name="RunShellcode"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqDN" syntax="SysreqDN(address, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawCreate" syntax="TextDrawCreate(x, y, text[])">
			<tagname value="Text"/>
			<attribute name="native"/>
			<referrer name="va_TextDrawCreate"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:ToHexStr" syntax="ToHexStr(x)">
			<stacksize value="15"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ToHexStr"/>
			<param name="x">
			</param>
		</member>
		<member name="M:ToPrintableAscii" syntax="ToPrintableAscii(c)">
			<stacksize value="4"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<dependency name="IsPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:Trim" syntax="Trim(str[], &amp;start, &amp;end)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to trim.
			</param>
			<param name="start">
				<paraminfo> &amp; </paraminfo>
				Start of the substring.
			</param>
			<param name="end">
				<paraminfo> &amp; </paraminfo>
				End of the substring.
			</param>
			      <remarks>  Modifies "start" and "end" to be tight on text in "str".  </remarks> 
		</member>
		<member name="M:UCMP" syntax="UCMP(value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The unsigned number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			    <returns>  An unsigned comparison between the two values.  </returns> 
		</member>
		<member name="M:UnrelocateOpcode" syntax="UnrelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:Utils_PreSort" syntax="Utils_PreSort(arr[], num)">
			<stacksize value="4"/>
			<referrer name="Mode"/>
			<referrer name="Median"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array to sort.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <remarks>  Sorts the array in place.  Uses bubble sort because it is easy and fast for  pre-sorted arrays (which the callers are likely to be).  </remarks> 
		</member>
		<member name="M:VALID_PLAYERID" syntax="VALID_PLAYERID(playerid)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="playerid">
				The player to check.
			</param>
			  <returns>  Is this a valid playerid (NOT, is the player connected).  </returns> 
		</member>
		<member name="M:WriteAmxCell" syntax="WriteAmxCell(offset, value)">
			<stacksize value="6"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="WritePhysMemoryCell"/>
			<param name="offset">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemory" syntax="WriteAmxMemory(address, value)">
			<stacksize value="1"/>
			<referrer name="WriteAmxMemoryArray"/>
			<referrer name="HookPublic"/>
			<referrer name="HookNative"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitPadding"/>
			<param name="address">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemoryArray" syntax="WriteAmxMemoryArray(address, values[], size)">
			<stacksize value="6"/>
			<dependency name="WriteAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:WritePhysMemory" syntax="WritePhysMemory(address, src[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:WritePhysMemoryCell" syntax="WritePhysMemoryCell(address, what)">
			<stacksize value="5"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="what">
			</param>
		</member>
		<member name="M:X@" syntax="X@(n)">
			<stacksize value="6"/>
			<dependency name="setproperty"/>
			<param name="n">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Y@" syntax="Y@()">
			<stacksize value="6"/>
			<dependency name="_@"/>
			<dependency name="setproperty"/>
		</member>
		<member name="M:YVA2_CodeGenDeepCleanup" syntax="YVA2_CodeGenDeepCleanup(ctx[], depth, returningString)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="cellbits"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="depth">
			</param>
			<param name="returningString">
			</param>
		</member>
		<member name="M:YVA2_CodeGenMainCleanup" syntax="YVA2_CodeGenMainCleanup(ctx[])">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushSite" syntax="YVA2_CodeGenPushSite(ctx[], pushedBytes, skippedBytes, offset)">
			<stacksize value="7"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitCallAbs"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="YVA2_DoPush"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="pushedBytes">
			</param>
			<param name="skippedBytes">
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushVariable" syntax="YVA2_CodeGenPushVariable(ctx[], stack)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPushS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="stack">
			</param>
		</member>
		<member name="M:YVA2_CodeGenShiftCode" syntax="YVA2_CodeGenShiftCode(dest, src, end)">
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<param name="dest">
			</param>
			<param name="src">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:YVA2_DoPush" syntax="YVA2_DoPush(skippedBytes, pushedBytes, pushRequirements)">
			<stacksize value="1"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="memcpy"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
		</member>
		<member name="M:YVA2_DummyPush" syntax="YVA2_DummyPush(skippedBytes, pushedBytes, pushRequirements, dummy0, dummy1, dummy2, dummy3, dummy4, dummy5)">
			<stacksize value="6"/>
			<referrer name="YVA2_Initalise"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<dependency name="Debug_Print0"/>
			<dependency name="TRUE"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YVA2_DoPush"/>
			<dependency name="YVA2_Initalise"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
			<param name="dummy0">
			</param>
			<param name="dummy1">
			</param>
			<param name="dummy2">
			</param>
			<param name="dummy3">
			</param>
			<param name="dummy4">
			</param>
			<param name="dummy5">
			</param>
		</member>
		<member name="M:YVA2_FoundCall" syntax="YVA2_FoundCall(m[])">
			<stacksize value="34"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="CodeScanGetMatchAddressData"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="YVA2_CodeGenDeepCleanup"/>
			<dependency name="YVA2_CodeGenMainCleanup"/>
			<dependency name="YVA2_CodeGenPushSite"/>
			<dependency name="YVA2_CodeGenPushVariable"/>
			<dependency name="YVA2_CodeGenShiftCode"/>
			<dependency name="cellbits"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="m">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_FoundPush" syntax="YVA2_FoundPush(m[])">
			<stacksize value="29"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanGetMatchAddress"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="max"/>
			<param name="m">
				<paraminfo> [163] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_Initalise" syntax="YVA2_Initalise()">
			<stacksize value="1138"/>
			<referrer name="YVA2_DummyPush"/>
			<dependency name="CodeScanAddMatcher"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatcher"/>
			<dependency name="CodeScanMatcherInit_"/>
			<dependency name="CodeScanMatcherPattern_"/>
			<dependency name="CodeScanRun"/>
			<dependency name="CodeScanner"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="YVA2_FoundCall"/>
			<dependency name="YVA2_FoundPush"/>
			<dependency name="gCodeScanCallback_match"/>
		</member>
		<member name="M:YVers_Callback" syntax="YVers_Callback(index, code, data[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="false"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="index">
			</param>
			<param name="code">
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YVers_OnScriptInit" syntax="YVers_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Debug_SetState"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<remarks>  Does some strange mangling of <c>YSI_FILTERSCRIPT</c> because at one point I  found a compiler bug where the first automata in the script could conflict  with the first variable in the script.  I don't know what triggered it, and  it has never shown up since I messed about with this file to try mangle some  things.  Never the less, if it ever happens again this code might detect it.  Actually, that's less likely now, since that variable is now very unlikely  to be the first in the script ever.  </remarks> 
		</member>
		<member name="M:Z@" syntax="Z@(v)">
			<stacksize value="7"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:_@_y_cgen_@_0" syntax="_@_y_cgen_@_0()">
			<attribute name="public"/>
			<stacksize value="60"/>
			<dependency name="SetTimerEx"/>
		</member>
		<member name="M:_@_y_cgen_@_1" syntax="_@_y_cgen_@_1()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:_@_y_funcinc_@_" syntax="_@_y_funcinc_@_()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="getproperty"/>
			<dependency name="heapspace"/>
			<dependency name="memcpy"/>
			<dependency name="memset"/>
			<dependency name="printf"/>
			<dependency name="setproperty"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:_HookChain_IncludeStates" syntax="_HookChain_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_Hooks_AddReplacement" syntax="_Hooks_AddReplacement(longName[], shortName[])">
			<stacksize value="5"/>
			<referrer name="@_yHCheckpoint"/>
			<referrer name="@_yHContainer"/>
			<referrer name="@_yHInventory"/>
			<referrer name="@_yHDynamic"/>
			<referrer name="@_yHTextDraw"/>
			<referrer name="@_yHUpdate"/>
			<referrer name="@_yHObject"/>
			<referrer name="@_yHCommand"/>
			<referrer name="@_yHDynamicCP"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="longName">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="shortName">
				<paraminfo> [] </paraminfo>
			</param>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks> 
		</member>
		<member name="M:_ScriptInit_FixState" syntax="_ScriptInit_FixState()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_script_init_fix_state"/>
		</member>
		<member name="M:_ScriptInit_IncludeStates" syntax="_ScriptInit_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:__CompilerSecondPass" syntax="__CompilerSecondPass()">
			<stacksize value="1"/>
		</member>
		<member name="M:__TU" syntax="__TU(t, iters)">
			<stacksize value="27"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="__TU"/>
			<dependency name="float"/>
			<dependency name="format"/>
			<param name="t">
				The time in ms.
			</param>
			<param name="iters">
				The number of iterations completed in this time.
			</param>
			    <remarks>  Formats and returns a string representing the time taken for one iteration,  given the time required for many iterations.  This attempts to format the  number using a reasonable fraction of a second.  </remarks> 
		</member>
		<member name="M:argderef" syntax="argderef(n)">
			<stacksize value="1"/>
			<dependency name="argderef"/>
			<param name="n">
			</param>
		</member>
		<member name="M:argref" syntax="argref(n)">
			<stacksize value="1"/>
			<param name="n">
			</param>
		</member>
		<member name="M:bernstein" syntax="bernstein(string[])">
			<stacksize value="28"/>
			<referrer name="bernstein"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitJnzRel"/>
			<dependency name="AsmEmitJzerRel"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSmulC"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmInitPtr"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				the string to hash.
			</param>
			  <returns>  the bernstein hash of the input string  </returns>  <remarks>  This is a 32bit hash system so is not very secure, however we're only  using this as a string enumerator to uniquely identify strings easilly  and allow for a binary search of strings based on the hash of their name.  crc32, then jenkins were originally used however this is far faster, if a  little collision prone, but we're checking the strings manually anyway.  This doesn't matter as it would be done regardless of hash method, so this  doesn't need to be accounted for.  Speed is all that matters with at   least a bit of non collision (the number of strings we're dealing with,  this should have none-few collisions).  I modified it slightly from the original code pasted by aru, to code  closer to the code <a href="http://www.burtleburtle.net/bob/hash/doobs.html" />  and to work with PAWN (and shaved 0.2s off the time for one call :D).  Uber reduced version (just for fun):  b(s[]){new h=-1,i,j;while((j=s[i++]))h=h*33+j;return h;}  Update: Contrary to what I said above this is also used to identify colour  strings for the updated text system involving file based styling and this  is not checked for collisions as it's unimportant.  But this doesn't affect  the function at all, I just mentioned it here for "interest".  Rewritten in self-generating assembly.  </remarks> 
		</member>
		<member name="M:binstr" syntax="binstr(string[])">
			<stacksize value="3"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This takes a value in 0110101 (boolean) format and returns it as a  regular value.  </remarks> 
		</member>
		<member name="M:boolstr" syntax="boolstr(string[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This can take a number of ways of representing booleans - 0, false and  nothing there.  Anything not one of those things (false is not case  sensitive) is assumed true.  </remarks> 
		</member>
		<member name="M:ceildiv" syntax="ceildiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			    <returns>  (numerator / denominator) rounded up.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this always rounds up.  </remarks> 
		</member>
		<member name="M:chrfind" syntax="chrfind(needle, haystack[], start)">
			<stacksize value="3"/>
			<dependency name="strlen"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns> 
		</member>
		<member name="M:chrfindp" syntax="chrfindp(needle, haystack[], start)">
			<stacksize value="1"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns>  <remarks>  Like <symbolref name="chrfind" />, but with no upper-bounds check on  <paramref name="start" />.  </remarks> 
		</member>
		<member name="M:copy_1" syntax="copy_1(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_2" syntax="copy_2(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_4" syntax="copy_4(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:deref" syntax="deref(v)">
			<stacksize value="1"/>
			<dependency name="deref"/>
			<param name="v">
			</param>
		</member>
		<member name="M:endofline" syntax="endofline(line[], pos)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="strlen"/>
			<param name="line">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			<param name="pos">
				Postion to start from.
			</param>
			    <remarks>  Checks if the current point in a line is the end of non-whitespace data.  </remarks> 
		</member>
		<member name="M:enter_public" syntax="enter_public(index, address)">
			<stacksize value="6"/>
			<referrer name="new_pec"/>
			<dependency name="ProfCallInfo"/>
			<dependency name="exit_public"/>
			<dependency name="g_call_depth"/>
			<dependency name="g_call_stack"/>
			<dependency name="g_call_stack"/>
			<dependency name="pci_index"/>
			<dependency name="pci_start_time"/>
			<dependency name="printf"/>
			<dependency name="tickcount"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:exit_public" syntax="exit_public()">
			<stacksize value="8"/>
			<referrer name="enter_public"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<dependency name="g_call_depth"/>
			<dependency name="g_call_stack"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="pci_index"/>
			<dependency name="pci_start_time"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="tickcount"/>
		</member>
		<member name="M:fclose" syntax="fclose(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="DisasmWrite"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="ftouch"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:fexist" syntax="fexist(pattern[])">
			<attribute name="native"/>
			<referrer name="ftouch"/>
			<referrer name="SledeciIDVozila"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:float" syntax="float(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<referrer name="operator+(Float:,_:)"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="value">
			</param>
		</member>
		<member name="M:floatadd" syntax="floatadd(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator+(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatcmp" syntax="floatcmp(oper1, oper2)">
			<attribute name="native"/>
			<referrer name="operator==(Float:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,Float:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,Float:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatdiv" syntax="floatdiv(dividend, divisor)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<param name="dividend">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="divisor">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatmul" syntax="floatmul(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatpower" syntax="floatpower(value, exponent)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="exponent">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatround" syntax="floatround(value, method)">
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="method">
				<paraminfo>floatround_method </paraminfo>
			</param>
		</member>
		<member name="M:floatsub" syntax="floatsub(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floordiv" syntax="floordiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			<summary>  floordiv(numerator, denominator);  </summary>      <returns>  (numerator / denominator) rounded down.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this also always rounds down,  making it a little pointless, but also more explicit in function.  </remarks> 
		</member>
		<member name="M:fopen" syntax="fopen(name[], mode)">
			<tagname value="File"/>
			<attribute name="native"/>
			<referrer name="DisasmWrite"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="ftouch"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="mode">
				<paraminfo>filemode </paraminfo>
			</param>
		</member>
		<member name="M:foreach" syntax="foreach()">
			<stacksize value="1"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnVehicleSpawn@001"/>
		</member>
		<member name="M:format" syntax="format(output[], len, format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Debug_PrintArray"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="__TU"/>
			<referrer name="va_return"/>
			<referrer name="Bit_Display"/>
			<referrer name="SledeciIDVozila"/>
			<referrer name="SacuvajVozilo"/>
			<referrer name="GetVehicleName"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnPlayerStateChange@001"/>
			<referrer name="v"/>
			<referrer name="nvozilo"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:ftouch" syntax="ftouch(filename[])">
			<stacksize value="5"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file to "touch".
			</param>
			<summary>  ftouch(filename);  </summary>    <returns>  0 - File already exists.  1 - File was created.  -1 - File was not created.  </returns>  <remarks>  This "touches" a file in the Unix sense of creating it but not opening or  editing it in any way.  </remarks> 
		</member>
		<member name="M:funcidx" syntax="funcidx(name[])">
			<attribute name="native"/>
			<referrer name="CGen_GetAddr"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:fwrite" syntax="fwrite(handle, string[])">
			<attribute name="native"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="va_fprintf"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:getarg" syntax="getarg(arg, index)">
			<attribute name="native"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:getproperty" syntax="getproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Z@"/>
			<referrer name="S@"/>
			<referrer name="F@"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:heapspace" syntax="heapspace()">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
		</member>
		<member name="M:hexstr" syntax="hexstr(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to convert to a number.
			</param>
			  <returns>  value of the passed hex string.  </returns>  <remarks>  Now stops on invalid characters.  </remarks> 
		</member>
		<member name="M:iseven" syntax="iseven(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is even.
			</param>
			 
		</member>
		<member name="M:ishex" syntax="ishex(str[])">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			  <returns>  true/false.  </returns> 
		</member>
		<member name="M:isnull" syntax="isnull(str[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check if is null.
			</param>
			 
		</member>
		<member name="M:isnumeric" syntax="isnumeric(str[])">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check
			</param>
			  <remarks>  Checks if a given string is numeric.  </remarks> 
		</member>
		<member name="M:isodd" syntax="isodd(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is odd.
			</param>
			 
		</member>
		<member name="M:max" syntax="max(value1, value2)">
			<attribute name="native"/>
			<referrer name="YVA2_FoundPush"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:memcpy" syntax="memcpy(dest[], source[], index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="rawMemcpy"/>
			<referrer name="YVA2_DoPush"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="index">
			</param>
			<param name="numbytes">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:memset" syntax="memset(arr[], val, size)">
			<stacksize value="7"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="rawMemset"/>
			<referrer name="Bit_SetAll"/>
			<dependency name="rawMemset"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				Array or address to set to a value.
			</param>
			<param name="val">
			</param>
			<param name="size">
			</param>
			  <param name="iValue">What to set the cells to.</param>  <param name="iSize">Number of cells to fill.</param>  <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:min" syntax="min(value1, value2)">
			<attribute name="native"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanAddJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:new_pec" syntax="new_pec(index, address, code_start)">
			<stacksize value="13"/>
			<referrer name="ProfilerInit"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="ProfEntryCode"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="enter_public"/>
			<dependency name="g_num_pecs"/>
			<dependency name="g_pecs"/>
			<dependency name="g_pecs"/>
			<dependency name="pec_call"/>
			<dependency name="pec_call_enter"/>
			<dependency name="pec_push_8"/>
			<dependency name="pec_push_address"/>
			<dependency name="pec_push_c0"/>
			<dependency name="pec_push_c1"/>
			<dependency name="pec_push_c2"/>
			<dependency name="pec_push_index"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
			<param name="code_start">
			</param>
		</member>
		<member name="M:numargs" syntax="numargs()">
			<attribute name="native"/>
			<referrer name="refabs"/>
			<referrer name="ref"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
		</member>
		<member name="M:nvozilo" syntax="nvozilo(playerid, params[])">
			<tagname value="CMD"/>
			<stacksize value="161"/>
			<dependency name="operator+(Float:,_:)"/>
			<dependency name="Boja1"/>
			<dependency name="Boja2"/>
			<dependency name="Cena"/>
			<dependency name="CreateDynamic3DTextLabel"/>
			<dependency name="CreateVehicle"/>
			<dependency name="DestroyVehicle"/>
			<dependency name="GRESKA"/>
			<dependency name="GetPlayerFacingAngle"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="GetPlayerVehicleID"/>
			<dependency name="GetVehicleName"/>
			<dependency name="GetVehicleName"/>
			<dependency name="ID"/>
			<dependency name="IsPlayerInAnyVehicle"/>
			<dependency name="KORISTI"/>
			<dependency name="Model"/>
			<dependency name="PosA"/>
			<dependency name="PosX"/>
			<dependency name="PosY"/>
			<dependency name="PosZ"/>
			<dependency name="SCM"/>
			<dependency name="SetPlayerPos"/>
			<dependency name="SetVehicleParamsEx"/>
			<dependency name="SledeciIDVozila"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="Zakljucan"/>
			<dependency name="format"/>
			<dependency name="sscanf"/>
			<dependency name="vImeVlasnika"/>
			<dependency name="voziloLabel"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:print" syntax="print(string[])">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnScriptInit"/>
			<referrer name="YVers_Callback"/>
			<referrer name="DumpStack"/>
			<referrer name="PrintStackTrace"/>
			<referrer name="va_print"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:printf" syntax="printf(format[], ...)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Debug_Print0"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="enter_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="DumpStack"/>
			<referrer name="PrintStackTrace"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:random" syntax="random(max)">
			<attribute name="native"/>
			<referrer name="Random"/>
			<referrer name="RandomFloat"/>
			<param name="max">
			</param>
		</member>
		<member name="M:rawMemcpy" syntax="rawMemcpy(dest, src, bytes)">
			<stacksize value="1"/>
			<dependency name="memcpy"/>
			<param name="dest">
				Destination address.
			</param>
			<param name="src">
				Source data.
			</param>
			<param name="bytes">
				Number of bytes to copy.
			</param>
			<summary>  rawMemcpy  </summary>        <remarks>  Like memcpy, but takes addresses instead of arrays.  Also far less secure.  </remarks> 
		</member>
		<member name="M:rawMemset" syntax="rawMemset(iAddress, iValue, iSize)">
			<stacksize value="28"/>
			<referrer name="memset"/>
			<referrer name="rawMemset"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitFill"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitShlCPri"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="memset"/>
			<param name="iAddress">
				Array or address to set to a value.
			</param>
			<param name="iValue">
				What to set the cells to.
			</param>
			<param name="iSize">
				Number of cells to fill.
			</param>
			      <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:ref" syntax="ref(...)">
			<stacksize value="2"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanAddMatcher"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:refabs" syntax="refabs(...)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="RelToAbs"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:returnstringarg" syntax="returnstringarg(idx)">
			<stacksize value="131"/>
			<dependency name="returnstringarg"/>
			<dependency name="strcat"/>
			<param name="idx">
				Index of the string in the parameters.
			</param>
			  <returns>  string  </returns>  <remarks>  Is passed the result of getarg, which will be the address of a string (in  theory) and uses that for DMA to get the string.  </remarks> 
		</member>
		<member name="M:setproperty" syntax="setproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="X@"/>
			<referrer name="Y@"/>
			<referrer name="Z@"/>
			<referrer name="S@"/>
			<referrer name="R@"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:sscanf" syntax="sscanf()">
			<stacksize value="1"/>
			<referrer name="nvozilo"/>
		</member>
		<member name="M:strcat" syntax="strcat(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="DisasmGetInsnName"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetMatchName"/>
			<referrer name="returnstringarg"/>
			<referrer name="va_getstring"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="_Hooks_AddReplacement"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strcmp" syntax="strcmp(string1[], string2[], ignorecase, length)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="boolstr"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="@yH_OnGameScriptInit@001"/>
			<referrer name="@yH_OnDialogResponse@001"/>
			<referrer name="@yH_OnVehicleMod@001"/>
			<referrer name="@yH_OnVehicleSpawn@001"/>
			<referrer name="@yH_OnPlayerStateChange@001"/>
			<referrer name="v"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="length">
			</param>
		</member>
		<member name="M:strcpy" syntax="strcpy(dest[], src[], len)">
			<stacksize value="1"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				Destination string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				Source string.
			</param>
			<param name="len">
				(Implicit) maximum length of the destination.
			</param>
			     
		</member>
		<member name="M:strdel" syntax="strdel(string[], start, end)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:strfind" syntax="strfind(string[], sub[], ignorecase, pos)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="sub">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="pos">
			</param>
		</member>
		<member name="M:strins" syntax="strins(string[], substr[], pos, maxlength)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="substr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="pos">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strlen" syntax="strlen(string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="StripNL"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="endofline"/>
			<referrer name="chrfind"/>
			<referrer name="unpack"/>
			<referrer name="va_strlen"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="_Hooks_AddReplacement"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:strpack" syntax="strpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strunpack" syntax="strunpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="unpack"/>
			<referrer name="S@"/>
			<referrer name="F@"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strval" syntax="strval(string[])">
			<attribute name="native"/>
			<referrer name="IPToInt"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:tickcount" syntax="tickcount(&amp;granularity)">
			<attribute name="native"/>
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
			<param name="granularity">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:tolower" syntax="tolower(c)">
			<attribute name="native"/>
			<referrer name="StrToLower"/>
			<param name="c">
			</param>
		</member>
		<member name="M:toupper" syntax="toupper(c)">
			<attribute name="native"/>
			<referrer name="StrToUpper"/>
			<param name="c">
			</param>
		</member>
		<member name="M:unpack" syntax="unpack(str[])">
			<stacksize value="135"/>
			<referrer name="Hooks_IsolateName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to unpack
			</param>
			  <returns>  unpacked string  </returns>  <remarks>  Mainly used for debugging.  </remarks> 
		</member>
		<member name="M:v" syntax="v(playerid, params[])">
			<tagname value="CMD"/>
			<stacksize value="543"/>
			<dependency name="GRESKA"/>
			<dependency name="GetName"/>
			<dependency name="GetVehicleName"/>
			<dependency name="GetVehicleName"/>
			<dependency name="Model"/>
			<dependency name="SPD"/>
			<dependency name="VI"/>
			<dependency name="VI"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<dependency name="vImeVlasnika"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:va_CreatePlayerTextDraw" syntax="va_CreatePlayerTextDraw(playerid, x, y, fmat[], ...)">
			<tagname value="PlayerText"/>
			<stacksize value="146"/>
			<dependency name="CreatePlayerTextDraw"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForAll" syntax="va_GameTextForAll(fmat[], time, style, ...)">
			<stacksize value="143"/>
			<dependency name="GameTextForAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForPlayer" syntax="va_GameTextForPlayer(playerid, fmat[], time, style, ...)">
			<stacksize value="144"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessage" syntax="va_SendClientMessage(playerid, colour, fmat[], ...)">
			<stacksize value="145"/>
			<dependency name="SendClientMessage"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessageToAll" syntax="va_SendClientMessageToAll(colour, fmat[], ...)">
			<stacksize value="144"/>
			<dependency name="SendClientMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToAll" syntax="va_SendPlayerMessageToAll(senderid, fmat[], ...)">
			<stacksize value="144"/>
			<dependency name="SendPlayerMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToPlayer" syntax="va_SendPlayerMessageToPlayer(playerid, senderid, fmat[], ...)">
			<stacksize value="145"/>
			<dependency name="SendPlayerMessageToPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_TextDrawCreate" syntax="va_TextDrawCreate(x, y, fmat[], ...)">
			<tagname value="Text"/>
			<stacksize value="145"/>
			<dependency name="TextDrawCreate"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_formatex" syntax="va_formatex(output[], size, fmat[], STATIC_ARGS)">
			<stacksize value="1"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="STATIC_ARGS">
				<paraminfo>va_ </paraminfo>
			</param>
		</member>
		<member name="M:va_fprintf" syntax="va_fprintf(fhnd, fmat[], ...)">
			<stacksize value="144"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="fwrite"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fhnd">
				<paraminfo>File </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_getstring" syntax="va_getstring(dest[], arg, len)">
			<stacksize value="1"/>
			<dependency name="strcat"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="arg">
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:va_print" syntax="va_print(fmat[], ...)">
			<stacksize value="143"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="print"/>
			<dependency name="va_return"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_return" syntax="va_return(fmat[], ...)">
			<stacksize value="131"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<dependency name="format"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
				String format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,Float,File,Text3D} </paraminfo>
				Parameters.
			</param>
			    <returns>  Formatted string.  </returns>  <remarks>  Just wraps `format` and returns a string instead.  Has extra code to ensure that it works correct on the old compiler.  </remarks> 
		</member>
		<member name="M:va_strlen" syntax="va_strlen(arg)">
			<stacksize value="1"/>
			<dependency name="strlen"/>
			<param name="arg">
			</param>
		</member>

	</members>
</doc>
